{"ast":null,"code":"import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\nexport function generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n  const useUint32 = triCount > 2 ** 16;\n  const byteCount = useUint32 ? 4 : 2;\n  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n  for (let i = 0, l = indirectBuffer.length; i < l; i++) {\n    indirectBuffer[i] = i;\n  }\n  return indirectBuffer;\n}\nexport function buildTree(bvh, triangleBounds, offset, count, options) {\n  // epxand variables\n  const {\n    maxDepth,\n    verbose,\n    maxLeafTris,\n    strategy,\n    onProgress,\n    indirect\n  } = options;\n  const indirectBuffer = bvh._indirectBuffer;\n  const geometry = bvh.geometry;\n  const indexArray = geometry.index ? geometry.index.array : null;\n  const partionFunc = indirect ? partition_indirect : partition;\n\n  // generate intermediate variables\n  const totalTriangles = getTriCount(geometry);\n  const cacheCentroidBoundingData = new Float32Array(6);\n  let reachedMaxDepth = false;\n  const root = new MeshBVHNode();\n  getBounds(triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData);\n  splitNode(root, offset, count, cacheCentroidBoundingData);\n  return root;\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    let centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(geometry);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      const left = new MeshBVHNode();\n      const lstart = offset;\n      const lcount = splitOffset - offset;\n      node.left = left;\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      const right = new MeshBVHNode();\n      const rstart = splitOffset;\n      const rcount = count - lcount;\n      node.right = right;\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n}\nexport function buildPackedTree(bvh, options) {\n  const geometry = bvh.geometry;\n  if (options.indirect) {\n    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n    if (hasGroupGaps(geometry) && !options.verbose) {\n      console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' + 'BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n  }\n  if (!bvh._indirectBuffer) {\n    ensureIndex(geometry, options);\n  }\n  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  const triangleBounds = computeTriangleBounds(geometry);\n  const geometryRanges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);\n  bvh._roots = geometryRanges.map(range => {\n    const root = buildTree(bvh, triangleBounds, range.offset, range.count, options);\n    const nodeCount = countNodes(root);\n    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    populateBuffer(0, root, buffer);\n    return buffer;\n  });\n}","map":{"version":3,"names":["ensureIndex","getFullGeometryRange","getRootIndexRanges","getTriCount","hasGroupGaps","getBounds","computeTriangleBounds","getOptimalSplit","MeshBVHNode","BYTES_PER_NODE","partition","partition_indirect","countNodes","populateBuffer","generateIndirectBuffer","geometry","useSharedArrayBuffer","triCount","index","count","attributes","position","useUint32","byteCount","buffer","SharedArrayBuffer","ArrayBuffer","indirectBuffer","Uint32Array","Uint16Array","i","l","length","buildTree","bvh","triangleBounds","offset","options","maxDepth","verbose","maxLeafTris","strategy","onProgress","indirect","_indirectBuffer","indexArray","array","partionFunc","totalTriangles","cacheCentroidBoundingData","Float32Array","reachedMaxDepth","root","boundingData","splitNode","triggerProgress","trianglesProcessed","node","centroidBoundingData","arguments","undefined","depth","console","warn","concat","split","axis","splitOffset","splitAxis","left","lstart","lcount","right","rstart","rcount","buildPackedTree","BufferConstructor","geometryRanges","_roots","map","range","nodeCount"],"sources":["C:/Users/admin/Desktop/All Custome Codes/BolbAnimation/Partical-Blob/node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/buildTree.js"],"sourcesContent":["import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\r\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\r\nimport { getOptimalSplit } from './splitUtils.js';\r\nimport { MeshBVHNode } from '../MeshBVHNode.js';\r\nimport { BYTES_PER_NODE } from '../Constants.js';\r\n\r\nimport { partition } from './sortUtils.generated.js';\r\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\r\nimport { countNodes, populateBuffer } from './buildUtils.js';\r\n\r\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\r\n\r\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\tconst useUint32 = triCount > 2 ** 16;\r\n\tconst byteCount = useUint32 ? 4 : 2;\r\n\r\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\r\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\r\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\r\n\r\n\t\tindirectBuffer[ i ] = i;\r\n\r\n\t}\r\n\r\n\treturn indirectBuffer;\r\n\r\n}\r\n\r\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\r\n\r\n\t// epxand variables\r\n\tconst {\r\n\t\tmaxDepth,\r\n\t\tverbose,\r\n\t\tmaxLeafTris,\r\n\t\tstrategy,\r\n\t\tonProgress,\r\n\t\tindirect,\r\n\t} = options;\r\n\tconst indirectBuffer = bvh._indirectBuffer;\r\n\tconst geometry = bvh.geometry;\r\n\tconst indexArray = geometry.index ? geometry.index.array : null;\r\n\tconst partionFunc = indirect ? partition_indirect : partition;\r\n\r\n\t// generate intermediate variables\r\n\tconst totalTriangles = getTriCount( geometry );\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst root = new MeshBVHNode();\r\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\r\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\r\n\treturn root;\r\n\r\n\tfunction triggerProgress( trianglesProcessed ) {\r\n\r\n\t\tif ( onProgress ) {\r\n\r\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function buildPackedTree( bvh, options ) {\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tif ( options.indirect ) {\r\n\r\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\r\n\r\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\r\n\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\r\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( ! bvh._indirectBuffer ) {\r\n\r\n\t\tensureIndex( geometry, options );\r\n\r\n\t}\r\n\r\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\r\n\tconst triangleBounds = computeTriangleBounds( geometry );\r\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\r\n\tbvh._roots = geometryRanges.map( range => {\r\n\r\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\r\n\t\tconst nodeCount = countNodes( root );\r\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\r\n\t\tpopulateBuffer( 0, root, buffer );\r\n\t\treturn buffer;\r\n\r\n\t} );\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}