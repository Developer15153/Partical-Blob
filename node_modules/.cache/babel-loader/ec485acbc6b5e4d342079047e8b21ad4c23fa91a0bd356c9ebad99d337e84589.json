{"ast":null,"code":"import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\nconst obb = /* @__PURE__ */new OrientedBox();\nconst tempBox = /* @__PURE__ */new Box3();\nexport const DEFAULT_OPTIONS = {\n  strategy: CENTER,\n  maxDepth: 40,\n  maxLeafTris: 10,\n  useSharedArrayBuffer: false,\n  setBoundingBox: true,\n  onProgress: null,\n  indirect: false,\n  verbose: true\n};\nexport class MeshBVH {\n  static serialize(bvh) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = {\n      cloneBuffers: true,\n      ...options\n    };\n    const geometry = bvh.geometry;\n    const rootData = bvh._roots;\n    const indirectBuffer = bvh._indirectBuffer;\n    const indexAttribute = geometry.getIndex();\n    let result;\n    if (options.cloneBuffers) {\n      result = {\n        roots: rootData.map(root => root.slice()),\n        index: indexAttribute ? indexAttribute.array.slice() : null,\n        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n      };\n    } else {\n      result = {\n        roots: rootData,\n        index: indexAttribute ? indexAttribute.array : null,\n        indirectBuffer: indirectBuffer\n      };\n    }\n    return result;\n  }\n  static deserialize(data, geometry) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    options = {\n      setIndex: true,\n      indirect: Boolean(data.indirectBuffer),\n      ...options\n    };\n    const {\n      index,\n      roots,\n      indirectBuffer\n    } = data;\n    const bvh = new MeshBVH(geometry, {\n      ...options,\n      [SKIP_GENERATION]: true\n    });\n    bvh._roots = roots;\n    bvh._indirectBuffer = indirectBuffer || null;\n    if (options.setIndex) {\n      const indexAttribute = geometry.getIndex();\n      if (indexAttribute === null) {\n        const newIndex = new BufferAttribute(data.index, 1, false);\n        geometry.setIndex(newIndex);\n      } else if (indexAttribute.array !== index) {\n        indexAttribute.array.set(index);\n        indexAttribute.needsUpdate = true;\n      }\n    }\n    return bvh;\n  }\n  get indirect() {\n    return !!this._indirectBuffer;\n  }\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign({\n      ...DEFAULT_OPTIONS,\n      // undocumented options\n\n      // Whether to skip generating the tree. Used for deserialization.\n      [SKIP_GENERATION]: false\n    }, options);\n    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n    this._roots = null;\n    this._indirectBuffer = null;\n    if (!options[SKIP_GENERATION]) {\n      buildPackedTree(this, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n    this.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[i] : i => i;\n  }\n  refit() {\n    let nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const refitFunc = this.indirect ? refit_indirect : refit;\n    return refitFunc(this, nodeIndices);\n  }\n  traverse(callback) {\n    let rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const buffer = this._roots[rootIndex];\n    const uint32Array = new Uint32Array(buffer);\n    const uint16Array = new Uint16Array(buffer);\n    _traverse(0);\n    function _traverse(node32Index) {\n      let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n      } else {\n        // TODO: use node functions here\n        const left = node32Index + BYTES_PER_NODE / 4;\n        const right = uint32Array[node32Index + 6];\n        const splitAxis = uint32Array[node32Index + 7];\n        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n        if (!stopTraversal) {\n          _traverse(left, depth + 1);\n          _traverse(right, depth + 1);\n        }\n      }\n    }\n  }\n\n  /* Core Cast Functions */\n  raycast(ray) {\n    let materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const intersects = [];\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n    const raycastFunc = this.indirect ? raycast_indirect : raycast;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      const startCount = intersects.length;\n      raycastFunc(this, i, materialSide, ray, intersects, near, far);\n      if (isArrayMaterial) {\n        const materialIndex = groups[i].materialIndex;\n        for (let j = startCount, jl = intersects.length; j < jl; j++) {\n          intersects[j].face.materialIndex = materialIndex;\n        }\n      }\n    }\n    return intersects;\n  }\n  raycastFirst(ray) {\n    let materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n    let near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    let closestResult = null;\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      const result = raycastFirstFunc(this, i, materialSide, ray, near, far);\n      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n        closestResult = result;\n        if (isArrayMaterial) {\n          result.face.materialIndex = groups[i].materialIndex;\n        }\n      }\n    }\n    return closestResult;\n  }\n  intersectsGeometry(otherGeometry, geomToMesh) {\n    let result = false;\n    const roots = this._roots;\n    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n      if (result) {\n        break;\n      }\n    }\n    return result;\n  }\n  shapecast(callbacks) {\n    const triangle = ExtendedTrianglePool.getPrimitive();\n    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n    let {\n      boundsTraverseOrder,\n      intersectsBounds,\n      intersectsRange,\n      intersectsTriangle\n    } = callbacks;\n\n    // wrap the intersectsRange function\n    if (intersectsRange && intersectsTriangle) {\n      const originalIntersectsRange = intersectsRange;\n      intersectsRange = (offset, count, contained, depth, nodeIndex) => {\n        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n        }\n        return true;\n      };\n    } else if (!intersectsRange) {\n      if (intersectsTriangle) {\n        intersectsRange = (offset, count, contained, depth) => {\n          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n        };\n      } else {\n        intersectsRange = (offset, count, contained) => {\n          return contained;\n        };\n      }\n    }\n\n    // run shapecast\n    let result = false;\n    let byteOffset = 0;\n    const roots = this._roots;\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const root = roots[i];\n      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n      if (result) {\n        break;\n      }\n      byteOffset += root.byteLength;\n    }\n    ExtendedTrianglePool.releasePrimitive(triangle);\n    return result;\n  }\n  bvhcast(otherBvh, matrixToLocal, callbacks) {\n    let {\n      intersectsRanges,\n      intersectsTriangles\n    } = callbacks;\n    const triangle1 = ExtendedTrianglePool.getPrimitive();\n    const indexAttr1 = this.geometry.index;\n    const positionAttr1 = this.geometry.attributes.position;\n    const assignTriangle1 = this.indirect ? i1 => {\n      const ti = this.resolveTriangleIndex(i1);\n      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);\n    } : i1 => {\n      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);\n    };\n    const triangle2 = ExtendedTrianglePool.getPrimitive();\n    const indexAttr2 = otherBvh.geometry.index;\n    const positionAttr2 = otherBvh.geometry.attributes.position;\n    const assignTriangle2 = otherBvh.indirect ? i2 => {\n      const ti2 = otherBvh.resolveTriangleIndex(i2);\n      setTriangle(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n    } : i2 => {\n      setTriangle(triangle2, i2 * 3, indexAttr2, positionAttr2);\n    };\n\n    // generate triangle callback if needed\n    if (intersectsTriangles) {\n      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {\n        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n          assignTriangle2(i2);\n          triangle2.a.applyMatrix4(matrixToLocal);\n          triangle2.b.applyMatrix4(matrixToLocal);\n          triangle2.c.applyMatrix4(matrixToLocal);\n          triangle2.needsUpdate = true;\n          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n            assignTriangle1(i1);\n            triangle1.needsUpdate = true;\n            if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n      if (intersectsRanges) {\n        const originalIntersectsRanges = intersectsRanges;\n        intersectsRanges = function (offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n          }\n          return true;\n        };\n      } else {\n        intersectsRanges = iterateOverDoubleTriangles;\n      }\n    }\n    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);\n  }\n\n  /* Derived Cast Functions */\n  intersectsBox(box, boxToMesh) {\n    obb.set(box.min, box.max, boxToMesh);\n    obb.needsUpdate = true;\n    return this.shapecast({\n      intersectsBounds: box => obb.intersectsBox(box),\n      intersectsTriangle: tri => obb.intersectsTriangle(tri)\n    });\n  }\n  intersectsSphere(sphere) {\n    return this.shapecast({\n      intersectsBounds: box => sphere.intersectsBox(box),\n      intersectsTriangle: tri => tri.intersectsSphere(sphere)\n    });\n  }\n  closestPointToGeometry(otherGeometry, geometryToBvh) {\n    let target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n    return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n  }\n  closestPointToPoint(point) {\n    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n    return closestPointToPoint(this, point, target, minThreshold, maxThreshold);\n  }\n  getBoundingBox(target) {\n    target.makeEmpty();\n    const roots = this._roots;\n    roots.forEach(buffer => {\n      arrayToBox(0, new Float32Array(buffer), tempBox);\n      target.union(tempBox);\n    });\n    return target;\n  }\n}","map":{"version":3,"names":["BufferAttribute","Box3","FrontSide","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","SKIP_GENERATION","buildPackedTree","OrientedBox","arrayToBox","ExtendedTrianglePool","shapecast","closestPointToPoint","iterateOverTriangles","refit","raycast","raycastFirst","intersectsGeometry","closestPointToGeometry","iterateOverTriangles_indirect","refit_indirect","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","closestPointToGeometry_indirect","isSharedArrayBufferSupported","setTriangle","bvhcast","obb","tempBox","DEFAULT_OPTIONS","strategy","maxDepth","maxLeafTris","useSharedArrayBuffer","setBoundingBox","onProgress","indirect","verbose","MeshBVH","serialize","bvh","options","arguments","length","undefined","cloneBuffers","geometry","rootData","_roots","indirectBuffer","_indirectBuffer","indexAttribute","getIndex","result","roots","map","root","slice","index","array","deserialize","data","setIndex","Boolean","newIndex","set","needsUpdate","constructor","isBufferGeometry","Error","isInterleavedBufferAttribute","Object","assign","boundingBox","getBoundingBox","resolveTriangleIndex","i","nodeIndices","refitFunc","traverse","callback","rootIndex","buffer","uint32Array","Uint32Array","uint16Array","Uint16Array","_traverse","node32Index","depth","node16Index","isLeaf","offset","count","Float32Array","left","right","splitAxis","stopTraversal","ray","materialOrSide","near","far","Infinity","intersects","isMaterial","isArrayMaterial","Array","isArray","groups","side","raycastFunc","l","materialSide","materialIndex","startCount","j","jl","face","closestResult","raycastFirstFunc","distance","otherGeometry","geomToMesh","intersectsGeometryFunc","callbacks","triangle","getPrimitive","iterateFunc","boundsTraverseOrder","intersectsBounds","intersectsRange","intersectsTriangle","originalIntersectsRange","contained","nodeIndex","byteOffset","byteLength","releasePrimitive","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","triangle1","indexAttr1","positionAttr1","attributes","position","assignTriangle1","i1","ti","triangle2","indexAttr2","positionAttr2","assignTriangle2","i2","ti2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","l2","a","applyMatrix4","b","c","l1","originalIntersectsRanges","intersectsBox","box","boxToMesh","min","max","tri","intersectsSphere","sphere","geometryToBvh","target1","target2","minThreshold","maxThreshold","closestPointToGeometryFunc","point","target","makeEmpty","forEach","union"],"sources":["C:/Users/admin/Desktop/All Custome Codes/BolbAnimation/Partical-Blob/node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"sourcesContent":["import { BufferAttribute, Box3, FrontSide } from 'three';\r\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\r\nimport { buildPackedTree } from './build/buildTree.js';\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\r\nimport { shapecast } from './cast/shapecast.js';\r\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\r\n\r\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\r\nimport { refit } from './cast/refit.generated.js';\r\nimport { raycast } from './cast/raycast.generated.js';\r\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\r\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\r\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\r\n\r\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\r\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\r\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\r\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\r\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\r\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\r\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\r\nimport { setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { bvhcast } from './cast/bvhcast.js';\r\n\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst tempBox = /* @__PURE__ */ new Box3();\r\nexport const DEFAULT_OPTIONS = {\r\n\tstrategy: CENTER,\r\n\tmaxDepth: 40,\r\n\tmaxLeafTris: 10,\r\n\tuseSharedArrayBuffer: false,\r\n\tsetBoundingBox: true,\r\n\tonProgress: null,\r\n\tindirect: false,\r\n\tverbose: true,\r\n};\r\n\r\nexport class MeshBVH {\r\n\r\n\tstatic serialize( bvh, options = {} ) {\r\n\r\n\t\toptions = {\r\n\t\t\tcloneBuffers: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst geometry = bvh.geometry;\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indirectBuffer = bvh._indirectBuffer;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tlet result;\r\n\t\tif ( options.cloneBuffers ) {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData.map( root => root.slice() ),\r\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\r\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData,\r\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\r\n\t\t\t\tindirectBuffer: indirectBuffer,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, options = {} ) {\r\n\r\n\t\toptions = {\r\n\t\t\tsetIndex: true,\r\n\t\t\tindirect: Boolean( data.indirectBuffer ),\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst { index, roots, indirectBuffer } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\t\tbvh._indirectBuffer = indirectBuffer || null;\r\n\r\n\t\tif ( options.setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tget indirect() {\r\n\r\n\t\treturn ! ! this._indirectBuffer;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\t...DEFAULT_OPTIONS,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false,\r\n\r\n\t\t}, options );\r\n\r\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\t\tthis._roots = null;\r\n\t\tthis._indirectBuffer = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tbuildPackedTree( this, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null ) {\r\n\r\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\r\n\t\treturn refitFunc( this, nodeIndices );\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// TODO: use node functions here\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst intersects = [];\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst startCount = intersects.length;\r\n\r\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\r\n\r\n\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\r\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\t\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\r\n\r\n\t\tlet result = false;\r\n\t\tconst roots = this._roots;\r\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( callbacks ) {\r\n\r\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\r\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\t// wrap the intersectsRange function\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// run shapecast\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst root = roots[ i ];\r\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\r\n\r\n\t\tlet {\r\n\t\t\tintersectsRanges,\r\n\t\t\tintersectsTriangles,\r\n\t\t} = callbacks;\r\n\r\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\r\n\t\tconst indexAttr1 = this.geometry.index;\r\n\t\tconst positionAttr1 = this.geometry.attributes.position;\r\n\t\tconst assignTriangle1 = this.indirect ?\r\n\t\t\ti1 => {\r\n\r\n\r\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\r\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\r\n\r\n\t\t\t} :\r\n\t\t\ti1 => {\r\n\r\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\r\n\r\n\t\t\t};\r\n\r\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\r\n\t\tconst indexAttr2 = otherBvh.geometry.index;\r\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\r\n\t\tconst assignTriangle2 = otherBvh.indirect ?\r\n\t\t\ti2 => {\r\n\r\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\r\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\r\n\r\n\t\t\t} :\r\n\t\t\ti2 => {\r\n\r\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\r\n\r\n\t\t\t};\r\n\r\n\t\t// generate triangle callback if needed\r\n\t\tif ( intersectsTriangles ) {\r\n\r\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\r\n\r\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\tassignTriangle2( i2 );\r\n\r\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\r\n\r\n\t\t\t\t\t\tassignTriangle1( i1 );\r\n\r\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( intersectsRanges ) {\r\n\r\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\r\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\r\n\r\n\t}\r\n\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\r\n\t\treturn closestPointToGeometryFunc(\r\n\t\t\tthis,\r\n\t\t\totherGeometry,\r\n\t\t\tgeometryToBvh,\r\n\t\t\ttarget1,\r\n\t\t\ttarget2,\r\n\t\t\tminThreshold,\r\n\t\t\tmaxThreshold,\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\treturn closestPointToPoint(\r\n\t\t\tthis,\r\n\t\t\tpoint,\r\n\t\t\ttarget,\r\n\t\t\tminThreshold,\r\n\t\t\tmaxThreshold,\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}