{"ast":null,"code":"/**\r\n * @monogrid/gainmap-js v3.0.5\r\n * With ❤️, by MONOGRID <rnd@monogrid.com>\r\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\nconst vertexShader = /* glsl */\"\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vUv = uv;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\";\nconst fragmentShader = /* glsl */\"\\n// min half float value\\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\\n// max half float value\\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\\n\\nuniform sampler2D sdr;\\nuniform sampler2D gainMap;\\nuniform vec3 gamma;\\nuniform vec3 offsetHdr;\\nuniform vec3 offsetSdr;\\nuniform vec3 gainMapMin;\\nuniform vec3 gainMapMax;\\nuniform float weightFactor;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\\n  vec3 logRecovery = pow( recovery, gamma );\\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\\n}\\n\";\n/**\r\n * A Material which is able to decode the Gainmap into a full HDR Representation\r\n *\r\n * @category Materials\r\n * @group Materials\r\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n  /**\r\n   *\r\n   * @param params\r\n   */\n  constructor(_ref) {\n    let {\n      gamma,\n      offsetHdr,\n      offsetSdr,\n      gainMapMin,\n      gainMapMax,\n      maxDisplayBoost,\n      hdrCapacityMin,\n      hdrCapacityMax,\n      sdr,\n      gainMap\n    } = _ref;\n    super({\n      name: 'GainMapDecoderMaterial',\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        sdr: {\n          value: sdr\n        },\n        gainMap: {\n          value: gainMap\n        },\n        gamma: {\n          value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n        },\n        offsetHdr: {\n          value: new Vector3().fromArray(offsetHdr)\n        },\n        offsetSdr: {\n          value: new Vector3().fromArray(offsetSdr)\n        },\n        gainMapMin: {\n          value: new Vector3().fromArray(gainMapMin)\n        },\n        gainMapMax: {\n          value: new Vector3().fromArray(gainMapMax)\n        },\n        weightFactor: {\n          value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n        }\n      },\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    this._maxDisplayBoost = maxDisplayBoost;\n    this._hdrCapacityMin = hdrCapacityMin;\n    this._hdrCapacityMax = hdrCapacityMax;\n    this.needsUpdate = true;\n    this.uniformsNeedUpdate = true;\n  }\n  get sdr() {\n    return this.uniforms.sdr.value;\n  }\n  set sdr(value) {\n    this.uniforms.sdr.value = value;\n  }\n  get gainMap() {\n    return this.uniforms.gainMap.value;\n  }\n  set gainMap(value) {\n    this.uniforms.gainMap.value = value;\n  }\n  /**\r\n   * @see {@link GainMapMetadata.offsetHdr}\r\n   */\n  get offsetHdr() {\n    return this.uniforms.offsetHdr.value.toArray();\n  }\n  set offsetHdr(value) {\n    this.uniforms.offsetHdr.value.fromArray(value);\n  }\n  /**\r\n   * @see {@link GainMapMetadata.offsetSdr}\r\n   */\n  get offsetSdr() {\n    return this.uniforms.offsetSdr.value.toArray();\n  }\n  set offsetSdr(value) {\n    this.uniforms.offsetSdr.value.fromArray(value);\n  }\n  /**\r\n   * @see {@link GainMapMetadata.gainMapMin}\r\n   */\n  get gainMapMin() {\n    return this.uniforms.gainMapMin.value.toArray();\n  }\n  set gainMapMin(value) {\n    this.uniforms.gainMapMin.value.fromArray(value);\n  }\n  /**\r\n   * @see {@link GainMapMetadata.gainMapMax}\r\n   */\n  get gainMapMax() {\n    return this.uniforms.gainMapMax.value.toArray();\n  }\n  set gainMapMax(value) {\n    this.uniforms.gainMapMax.value.fromArray(value);\n  }\n  /**\r\n   * @see {@link GainMapMetadata.gamma}\r\n   */\n  get gamma() {\n    const g = this.uniforms.gamma.value;\n    return [1 / g.x, 1 / g.y, 1 / g.z];\n  }\n  set gamma(value) {\n    const g = this.uniforms.gamma.value;\n    g.x = 1.0 / value[0];\n    g.y = 1.0 / value[1];\n    g.z = 1.0 / value[2];\n  }\n  /**\r\n   * @see {@link GainMapMetadata.hdrCapacityMin}\r\n   * @remarks Logarithmic space\r\n   */\n  get hdrCapacityMin() {\n    return this._hdrCapacityMin;\n  }\n  set hdrCapacityMin(value) {\n    this._hdrCapacityMin = value;\n    this.calculateWeight();\n  }\n  /**\r\n   * @see {@link GainMapMetadata.hdrCapacityMin}\r\n   * @remarks Logarithmic space\r\n   */\n  get hdrCapacityMax() {\n    return this._hdrCapacityMax;\n  }\n  set hdrCapacityMax(value) {\n    this._hdrCapacityMax = value;\n    this.calculateWeight();\n  }\n  /**\r\n   * @see {@link GainmapDecodingParameters.maxDisplayBoost}\r\n   * @remarks Non Logarithmic space\r\n   */\n  get maxDisplayBoost() {\n    return this._maxDisplayBoost;\n  }\n  set maxDisplayBoost(value) {\n    this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n    this.calculateWeight();\n  }\n  calculateWeight() {\n    const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n  }\n}\n\n/**\r\n * Decodes a gain map using a WebGLRenderTarget\r\n *\r\n * @category Decoding Functions\r\n * @group Decoding Functions\r\n * @example\r\n * import { decode } from '@monogrid/gainmap-js'\r\n * import {\r\n *   Mesh,\r\n *   MeshBasicMaterial,\r\n *   PerspectiveCamera,\r\n *   PlaneGeometry,\r\n *   Scene,\r\n *   TextureLoader,\r\n *   WebGLRenderer\r\n * } from 'three'\r\n *\r\n * const renderer = new WebGLRenderer()\r\n *\r\n * const textureLoader = new TextureLoader()\r\n *\r\n * // load SDR Representation\r\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\r\n * // load Gain map recovery image\r\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\r\n * // load metadata\r\n * const metadata = await (await fetch('metadata.json')).json()\r\n *\r\n * const result = await decode({\r\n *   sdr,\r\n *   gainMap,\r\n *   // this allows to use `result.renderTarget.texture` directly\r\n *   renderer,\r\n *   // this will restore the full HDR range\r\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\r\n *   ...metadata\r\n * })\r\n *\r\n * const scene = new Scene()\r\n * // `result` can be used to populate a Texture\r\n * const mesh = new Mesh(\r\n *   new PlaneGeometry(),\r\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\r\n * )\r\n * scene.add(mesh)\r\n * renderer.render(scene, new PerspectiveCamera())\r\n *\r\n * // result must be manually disposed\r\n * // when you are done using it\r\n * result.dispose()\r\n *\r\n * @param params\r\n * @returns\r\n * @throws {Error} if the WebGLRenderer fails to render the gain map\r\n */\nconst decode = params => {\n  const {\n    sdr,\n    gainMap,\n    renderer\n  } = params;\n  if (sdr.colorSpace !== SRGBColorSpace) {\n    console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n    sdr.colorSpace = SRGBColorSpace;\n  }\n  sdr.needsUpdate = true;\n  if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n    console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n    gainMap.colorSpace = LinearSRGBColorSpace;\n  }\n  gainMap.needsUpdate = true;\n  const material = new GainMapDecoderMaterial({\n    ...params,\n    sdr,\n    gainMap\n  });\n  const quadRenderer = new QuadRenderer({\n    // TODO: three types are generic, eslint complains here, see how we can solve\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    width: sdr.image.width,\n    // TODO: three types are generic, eslint complains here, see how we can solve\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    height: sdr.image.height,\n    type: HalfFloatType,\n    colorSpace: LinearSRGBColorSpace,\n    material,\n    renderer,\n    renderTargetOptions: params.renderTargetOptions\n  });\n  try {\n    quadRenderer.render();\n  } catch (e) {\n    quadRenderer.disposeOnDemandRenderer();\n    throw e;\n  }\n  return quadRenderer;\n};\nclass GainMapNotFoundError extends Error {}\nclass XMPMetadataNotFoundError extends Error {}\nconst getAttribute = (description, name, defaultValue) => {\n  var _a;\n  let returnValue;\n  const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n  if (!parsedValue) {\n    const node = description.getElementsByTagName(name)[0];\n    if (node) {\n      const values = node.getElementsByTagName('rdf:li');\n      if (values.length === 3) {\n        returnValue = Array.from(values).map(v => v.innerHTML);\n      } else {\n        throw new Error(\"Gainmap metadata contains an array of items for \".concat(name, \" but its length is not 3\"));\n      }\n    } else {\n      if (defaultValue) return defaultValue;else throw new Error(\"Can't find \".concat(name, \" in gainmap metadata\"));\n    }\n  } else {\n    returnValue = parsedValue;\n  }\n  return returnValue;\n};\n/**\r\n *\r\n * @param input\r\n * @returns\r\n */\nconst extractXMP = input => {\n  var _a, _b;\n  let str;\n  // support node test environment\n  if (typeof TextDecoder !== 'undefined') str = new TextDecoder().decode(input);else str = input.toString();\n  let start = str.indexOf('<x:xmpmeta');\n  const parser = new DOMParser();\n  while (start !== -1) {\n    const end = str.indexOf('x:xmpmeta>', start);\n    str.slice(start, end + 10);\n    const xmpBlock = str.slice(start, end + 10);\n    try {\n      const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n      const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n      const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n      const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n      const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n      const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n      const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n      let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n      if (!hdrCapacityMin) hdrCapacityMin = '0';\n      const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n      if (!hdrCapacityMax) throw new Error('Incomplete gainmap metadata');\n      return {\n        gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n        gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n        gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n        offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n        offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n        hdrCapacityMin: parseFloat(hdrCapacityMin),\n        hdrCapacityMax: parseFloat(hdrCapacityMax)\n      };\n    } catch (e) {}\n    start = str.indexOf('<x:xmpmeta', end);\n  }\n};\n\n/**\r\n * MPF Extractor (Multi Picture Format Extractor)\r\n * By Henrik S Nilsson 2019\r\n *\r\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\r\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\r\n *\r\n * Overly commented, and without intention of being complete or production ready.\r\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\r\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\r\n */\nclass MPFExtractor {\n  constructor(options) {\n    this.options = {\n      debug: options && options.debug !== undefined ? options.debug : false,\n      extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n      extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n    };\n  }\n  extract(imageArrayBuffer) {\n    return new Promise((resolve, reject) => {\n      const debug = this.options.debug;\n      const dataView = new DataView(imageArrayBuffer.buffer);\n      // If you're executing this line on a big endian machine, it'll be reversed.\n      // bigEnd further down though, refers to the endianness of the image itself.\n      if (dataView.getUint16(0) !== 0xffd8) {\n        reject(new Error('Not a valid jpeg'));\n        return;\n      }\n      const length = dataView.byteLength;\n      let offset = 2;\n      let loops = 0;\n      let marker; // APP# marker\n      while (offset < length) {\n        if (++loops > 250) {\n          reject(new Error(\"Found no marker after \".concat(loops, \" loops \\uD83D\\uDE35\")));\n          return;\n        }\n        if (dataView.getUint8(offset) !== 0xff) {\n          reject(new Error(\"Not a valid marker at offset 0x\".concat(offset.toString(16), \", found: 0x\").concat(dataView.getUint8(offset).toString(16))));\n          return;\n        }\n        marker = dataView.getUint8(offset + 1);\n        if (debug) console.log(\"Marker: \".concat(marker.toString(16)));\n        if (marker === 0xe2) {\n          if (debug) console.log('Found APP2 marker (0xffe2)');\n          // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n          // Great way to visualize image information in html is using Exiftool. E.g.:\n          // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n          const formatPt = offset + 4;\n          /*\r\n           *  Structure of the MP Format Identifier\r\n           *\r\n           *  Offset Addr.  | Code (Hex)  | Description\r\n           *  +00             ff            Marker Prefix      <-- offset\r\n           *  +01             e2            APP2\r\n           *  +02             #n            APP2 Field Length\r\n           *  +03             #n            APP2 Field Length\r\n           *  +04             4d            'M'                <-- formatPt\r\n           *  +05             50            'P'\r\n           *  +06             46            'F'\r\n           *  +07             00            NULL\r\n           *                                                   <-- tiffOffset\r\n           */\n          if (dataView.getUint32(formatPt) === 0x4d504600) {\n            // Found MPF tag, so we start dig out sub images\n            const tiffOffset = formatPt + 4;\n            let bigEnd; // Endianness from TIFF header\n            // Test for TIFF validity and endianness\n            // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n            if (dataView.getUint16(tiffOffset) === 0x4949) {\n              bigEnd = false;\n            } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n              bigEnd = true;\n            } else {\n              reject(new Error('No valid endianness marker found in TIFF header'));\n              return;\n            }\n            if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n              reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n              return;\n            }\n            // 32 bit number stating the offset from the start of the 8 Byte MP Header\n            // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n            const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n            if (firstIFDOffset < 0x00000008) {\n              reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n              return;\n            }\n            // Move ahead to MP Index IFD\n            // Assume we're at the first IFD, so firstIFDOffset points to\n            // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n            // we fail silently here due to this assumption)\n            // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n            const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n            const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n            // Extract info from MPEntries (starting after Count)\n            const entriesStart = dirStart + 2;\n            let numberOfImages = 0;\n            for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n              // Each entry is 12 Bytes long\n              // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n              if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                // stored in Last 4 bytes of its 12 Byte entry.\n                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n              }\n            }\n            const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n            const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n            const images = [];\n            for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n              const image = {\n                MPType: dataView.getUint32(i, !bigEnd),\n                size: dataView.getUint32(i + 4, !bigEnd),\n                // This offset is specified relative to the address of the MP Endian\n                // field in the MP Header, unless the image is a First Individual Image,\n                // in which case the value of the offset shall be NULL (0x00000000).\n                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                start: -1,\n                end: -1,\n                isFII: false\n              };\n              if (!image.dataOffset) {\n                // dataOffset is 0x00000000 for First Individual Image\n                image.start = 0;\n                image.isFII = true;\n              } else {\n                image.start = tiffOffset + image.dataOffset;\n                image.isFII = false;\n              }\n              image.end = image.start + image.size;\n              images.push(image);\n            }\n            if (this.options.extractNonFII && images.length) {\n              const bufferBlob = new Blob([dataView]);\n              const imgs = [];\n              for (const image of images) {\n                if (image.isFII && !this.options.extractFII) {\n                  continue; // Skip FII\n                }\n                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                // we don't need this\n                // const imageUrl = URL.createObjectURL(imageBlob)\n                // image.img = document.createElement('img')\n                // image.img.src = imageUrl\n                imgs.push(imageBlob);\n              }\n              resolve(imgs);\n            }\n          }\n        }\n        offset += 2 + dataView.getUint16(offset + 2);\n      }\n    });\n  }\n}\n\n/**\r\n * Extracts XMP Metadata and the gain map recovery image\r\n * from a single JPEG file.\r\n *\r\n * @category Decoding Functions\r\n * @group Decoding Functions\r\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\r\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\r\n * @throws Error if XMP Metadata is not found\r\n * @throws Error if Gain map image is not found\r\n * @example\r\n * import { FileLoader } from 'three'\r\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\r\n *\r\n * const jpegFile = await new FileLoader()\r\n *  .setResponseType('arraybuffer')\r\n *  .loadAsync('image.jpg')\r\n *\r\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\r\n */\nconst extractGainmapFromJPEG = async jpegFile => {\n  const metadata = extractXMP(jpegFile);\n  if (!metadata) throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n  const mpfExtractor = new MPFExtractor({\n    extractFII: true,\n    extractNonFII: true\n  });\n  const images = await mpfExtractor.extract(jpegFile);\n  if (images.length !== 2) throw new GainMapNotFoundError('Gain map recovery image not found');\n  return {\n    sdr: new Uint8Array(await images[0].arrayBuffer()),\n    gainMap: new Uint8Array(await images[1].arrayBuffer()),\n    metadata\n  };\n};\n\n/**\r\n * private function, async get image from blob\r\n *\r\n * @param blob\r\n * @returns\r\n */\nconst getHTMLImageFromBlob = blob => {\n  return new Promise((resolve, reject) => {\n    const img = document.createElement('img');\n    img.onload = () => {\n      resolve(img);\n    };\n    img.onerror = e => {\n      reject(e);\n    };\n    img.src = URL.createObjectURL(blob);\n  });\n};\nclass LoaderBase extends Loader {\n  /**\r\n   *\r\n   * @param renderer\r\n   * @param manager\r\n   */\n  constructor(renderer, manager) {\n    super(manager);\n    if (renderer) this._renderer = renderer;\n    this._internalLoadingManager = new LoadingManager();\n  }\n  /**\r\n   * Specify the renderer to use when rendering the gain map\r\n   *\r\n   * @param renderer\r\n   * @returns\r\n   */\n  setRenderer(renderer) {\n    this._renderer = renderer;\n    return this;\n  }\n  /**\r\n   * Specify the renderTarget options to use when rendering the gain map\r\n   *\r\n   * @param options\r\n   * @returns\r\n   */\n  setRenderTargetOptions(options) {\n    this._renderTargetOptions = options;\n    return this;\n  }\n  /**\r\n   * @private\r\n   * @returns\r\n   */\n  prepareQuadRenderer() {\n    if (!this._renderer) console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n    // temporary values\n    const material = new GainMapDecoderMaterial({\n      gainMapMax: [1, 1, 1],\n      gainMapMin: [0, 0, 0],\n      gamma: [1, 1, 1],\n      offsetHdr: [1, 1, 1],\n      offsetSdr: [1, 1, 1],\n      hdrCapacityMax: 1,\n      hdrCapacityMin: 0,\n      maxDisplayBoost: 1,\n      gainMap: new Texture(),\n      sdr: new Texture()\n    });\n    return new QuadRenderer({\n      width: 16,\n      height: 16,\n      type: HalfFloatType,\n      colorSpace: LinearSRGBColorSpace,\n      material,\n      renderer: this._renderer,\n      renderTargetOptions: this._renderTargetOptions\n    });\n  }\n  /**\r\n  * @private\r\n  * @param quadRenderer\r\n  * @param metadata\r\n  * @param sdrBuffer\r\n  * @param gainMapBuffer\r\n  */\n  async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n    // this is optional, will render a black gain-map if not present\n    const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], {\n      type: 'image/jpeg'\n    }) : undefined;\n    const sdrBlob = new Blob([sdrBuffer], {\n      type: 'image/jpeg'\n    });\n    let sdrImage;\n    let gainMapImage;\n    let needsFlip = false;\n    if (typeof createImageBitmap === 'undefined') {\n      const res = await Promise.all([gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined), getHTMLImageFromBlob(sdrBlob)]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n      needsFlip = true;\n    } else {\n      const res = await Promise.all([gainMapBlob ? createImageBitmap(gainMapBlob, {\n        imageOrientation: 'flipY'\n      }) : Promise.resolve(undefined), createImageBitmap(sdrBlob, {\n        imageOrientation: 'flipY'\n      })]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n    }\n    const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n    gainMap.flipY = needsFlip;\n    gainMap.needsUpdate = true;\n    const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n    sdr.flipY = needsFlip;\n    sdr.needsUpdate = true;\n    quadRenderer.width = sdrImage.width;\n    quadRenderer.height = sdrImage.height;\n    quadRenderer.material.gainMap = gainMap;\n    quadRenderer.material.sdr = sdr;\n    quadRenderer.material.gainMapMin = metadata.gainMapMin;\n    quadRenderer.material.gainMapMax = metadata.gainMapMax;\n    quadRenderer.material.offsetHdr = metadata.offsetHdr;\n    quadRenderer.material.offsetSdr = metadata.offsetSdr;\n    quadRenderer.material.gamma = metadata.gamma;\n    quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n    quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n    quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n    quadRenderer.material.needsUpdate = true;\n    quadRenderer.render();\n  }\n}\n\n/**\r\n * A Three.js Loader for the gain map format.\r\n *\r\n * @category Loaders\r\n * @group Loaders\r\n *\r\n * @example\r\n * import { GainMapLoader } from '@monogrid/gainmap-js'\r\n * import {\r\n *   EquirectangularReflectionMapping,\r\n *   LinearFilter,\r\n *   Mesh,\r\n *   MeshBasicMaterial,\r\n *   PerspectiveCamera,\r\n *   PlaneGeometry,\r\n *   Scene,\r\n *   WebGLRenderer\r\n * } from 'three'\r\n *\r\n * const renderer = new WebGLRenderer()\r\n *\r\n * const loader = new GainMapLoader(renderer)\r\n *\r\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\r\n * // `result` can be used to populate a Texture\r\n *\r\n * const scene = new Scene()\r\n * const mesh = new Mesh(\r\n *   new PlaneGeometry(),\r\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\r\n * )\r\n * scene.add(mesh)\r\n * renderer.render(scene, new PerspectiveCamera())\r\n *\r\n * // Starting from three.js r159\r\n * // `result.renderTarget.texture` can\r\n * // also be used as Equirectangular scene background\r\n * //\r\n * // it was previously needed to convert it\r\n * // to a DataTexture with `result.toDataTexture()`\r\n * scene.background = result.renderTarget.texture\r\n * scene.background.mapping = EquirectangularReflectionMapping\r\n *\r\n * // result must be manually disposed\r\n * // when you are done using it\r\n * result.dispose()\r\n *\r\n */\nclass GainMapLoader extends LoaderBase {\n  /**\r\n   * Loads a gainmap using separate data\r\n   * * sdr image\r\n   * * gain map image\r\n   * * metadata json\r\n   *\r\n   * useful for webp gain maps\r\n   *\r\n   * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\r\n   * @param onLoad Load complete callback, will receive the result\r\n   * @param onProgress Progress callback, will receive a {@link ProgressEvent}\r\n   * @param onError Error callback\r\n   * @returns\r\n   */\n  load(_ref2, onLoad, onProgress, onError) {\n    let [sdrUrl, gainMapUrl, metadataUrl] = _ref2;\n    const quadRenderer = this.prepareQuadRenderer();\n    let sdr;\n    let gainMap;\n    let metadata;\n    const loadCheck = async () => {\n      if (sdr && gainMap && metadata) {\n        // solves #16\n        try {\n          await this.render(quadRenderer, metadata, sdr, gainMap);\n        } catch (error) {\n          this.manager.itemError(sdrUrl);\n          this.manager.itemError(gainMapUrl);\n          this.manager.itemError(metadataUrl);\n          if (typeof onError === 'function') onError(error);\n          quadRenderer.disposeOnDemandRenderer();\n          return;\n        }\n        if (typeof onLoad === 'function') onLoad(quadRenderer);\n        this.manager.itemEnd(sdrUrl);\n        this.manager.itemEnd(gainMapUrl);\n        this.manager.itemEnd(metadataUrl);\n        quadRenderer.disposeOnDemandRenderer();\n      }\n    };\n    let sdrLengthComputable = true;\n    let sdrTotal = 0;\n    let sdrLoaded = 0;\n    let gainMapLengthComputable = true;\n    let gainMapTotal = 0;\n    let gainMapLoaded = 0;\n    let metadataLengthComputable = true;\n    let metadataTotal = 0;\n    let metadataLoaded = 0;\n    const progressHandler = () => {\n      if (typeof onProgress === 'function') {\n        const total = sdrTotal + gainMapTotal + metadataTotal;\n        const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n        const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n        onProgress(new ProgressEvent('progress', {\n          lengthComputable,\n          loaded,\n          total\n        }));\n      }\n    };\n    this.manager.itemStart(sdrUrl);\n    this.manager.itemStart(gainMapUrl);\n    this.manager.itemStart(metadataUrl);\n    const sdrLoader = new FileLoader(this._internalLoadingManager);\n    sdrLoader.setResponseType('arraybuffer');\n    sdrLoader.setRequestHeader(this.requestHeader);\n    sdrLoader.setPath(this.path);\n    sdrLoader.setWithCredentials(this.withCredentials);\n    sdrLoader.load(sdrUrl, async buffer => {\n      /* istanbul ignore if\r\n       this condition exists only because of three.js types + strict mode\r\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid sdr buffer');\n      sdr = buffer;\n      await loadCheck();\n    }, e => {\n      sdrLengthComputable = e.lengthComputable;\n      sdrLoaded = e.loaded;\n      sdrTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(sdrUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const gainMapLoader = new FileLoader(this._internalLoadingManager);\n    gainMapLoader.setResponseType('arraybuffer');\n    gainMapLoader.setRequestHeader(this.requestHeader);\n    gainMapLoader.setPath(this.path);\n    gainMapLoader.setWithCredentials(this.withCredentials);\n    gainMapLoader.load(gainMapUrl, async buffer => {\n      /* istanbul ignore if\r\n       this condition exists only because of three.js types + strict mode\r\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid gainmap buffer');\n      gainMap = buffer;\n      await loadCheck();\n    }, e => {\n      gainMapLengthComputable = e.lengthComputable;\n      gainMapLoaded = e.loaded;\n      gainMapTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(gainMapUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const metadataLoader = new FileLoader(this._internalLoadingManager);\n    // metadataLoader.setResponseType('json')\n    metadataLoader.setRequestHeader(this.requestHeader);\n    metadataLoader.setPath(this.path);\n    metadataLoader.setWithCredentials(this.withCredentials);\n    metadataLoader.load(metadataUrl, async json => {\n      /* istanbul ignore if\r\n       this condition exists only because of three.js types + strict mode\r\n      */\n      if (typeof json !== 'string') throw new Error('Invalid metadata string');\n      // TODO: implement check on JSON file and remove this eslint disable\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      metadata = JSON.parse(json);\n      await loadCheck();\n    }, e => {\n      metadataLengthComputable = e.lengthComputable;\n      metadataLoaded = e.loaded;\n      metadataTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(metadataUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\n\n/**\r\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\r\n *\r\n * @category Loaders\r\n * @group Loaders\r\n *\r\n * @example\r\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\r\n * import {\r\n *   EquirectangularReflectionMapping,\r\n *   LinearFilter,\r\n *   Mesh,\r\n *   MeshBasicMaterial,\r\n *   PerspectiveCamera,\r\n *   PlaneGeometry,\r\n *   Scene,\r\n *   WebGLRenderer\r\n * } from 'three'\r\n *\r\n * const renderer = new WebGLRenderer()\r\n *\r\n * const loader = new HDRJPGLoader(renderer)\r\n *\r\n * const result = await loader.loadAsync('gainmap.jpeg')\r\n * // `result` can be used to populate a Texture\r\n *\r\n * const scene = new Scene()\r\n * const mesh = new Mesh(\r\n *   new PlaneGeometry(),\r\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\r\n * )\r\n * scene.add(mesh)\r\n * renderer.render(scene, new PerspectiveCamera())\r\n *\r\n * // Starting from three.js r159\r\n * // `result.renderTarget.texture` can\r\n * // also be used as Equirectangular scene background\r\n * //\r\n * // it was previously needed to convert it\r\n * // to a DataTexture with `result.toDataTexture()`\r\n * scene.background = result.renderTarget.texture\r\n * scene.background.mapping = EquirectangularReflectionMapping\r\n *\r\n * // result must be manually disposed\r\n * // when you are done using it\r\n * result.dispose()\r\n *\r\n */\nclass HDRJPGLoader extends LoaderBase {\n  /**\r\n   * Loads a JPEG containing gain map metadata\r\n   * Renders a normal SDR image if gainmap data is not found\r\n   *\r\n   * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\r\n   * @param onLoad Load complete callback, will receive the result\r\n   * @param onProgress Progress callback, will receive a {@link ProgressEvent}\r\n   * @param onError Error callback\r\n   * @returns\r\n   */\n  load(url, onLoad, onProgress, onError) {\n    const quadRenderer = this.prepareQuadRenderer();\n    const loader = new FileLoader(this._internalLoadingManager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    this.manager.itemStart(url);\n    loader.load(url, async jpeg => {\n      /* istanbul ignore if\r\n       this condition exists only because of three.js types + strict mode\r\n      */\n      if (typeof jpeg === 'string') throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n      const jpegBuffer = new Uint8Array(jpeg);\n      let sdrJPEG;\n      let gainMapJPEG;\n      let metadata;\n      try {\n        const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n        // gain map is successfully reconstructed\n        sdrJPEG = extractionResult.sdr;\n        gainMapJPEG = extractionResult.gainMap;\n        metadata = extractionResult.metadata;\n      } catch (e) {\n        // render the SDR version if this is not a gainmap\n        if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n          console.warn(\"Failure to reconstruct an HDR image from \".concat(url, \": Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg\"));\n          metadata = {\n            gainMapMin: [0, 0, 0],\n            gainMapMax: [1, 1, 1],\n            gamma: [1, 1, 1],\n            hdrCapacityMin: 0,\n            hdrCapacityMax: 1,\n            offsetHdr: [0, 0, 0],\n            offsetSdr: [0, 0, 0]\n          };\n          sdrJPEG = jpegBuffer;\n        } else {\n          throw e;\n        }\n      }\n      // solves #16\n      try {\n        await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n      } catch (error) {\n        this.manager.itemError(url);\n        if (typeof onError === 'function') onError(error);\n        quadRenderer.disposeOnDemandRenderer();\n        return;\n      }\n      if (typeof onLoad === 'function') onLoad(quadRenderer);\n      this.manager.itemEnd(url);\n      quadRenderer.disposeOnDemandRenderer();\n    }, onProgress, error => {\n      this.manager.itemError(url);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };","map":{"version":3,"names":["Q","QuadRenderer","ShaderMaterial","Vector3","NoBlending","SRGBColorSpace","LinearSRGBColorSpace","HalfFloatType","Loader","LoadingManager","Texture","UVMapping","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","FileLoader","vertexShader","fragmentShader","GainMapDecoderMaterial","constructor","_ref","gamma","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","name","uniforms","value","fromArray","weightFactor","Math","log2","blending","depthTest","depthWrite","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","toArray","g","x","y","z","calculateWeight","max","min","val","decode","params","renderer","colorSpace","console","warn","material","quadRenderer","width","image","height","type","renderTargetOptions","render","e","disposeOnDemandRenderer","GainMapNotFoundError","Error","XMPMetadataNotFoundError","getAttribute","description","defaultValue","_a","returnValue","parsedValue","attributes","getNamedItem","nodeValue","node","getElementsByTagName","values","length","Array","from","map","v","innerHTML","concat","extractXMP","input","_b","str","TextDecoder","toString","start","indexOf","parser","DOMParser","end","slice","xmpBlock","xmlDocument","parseFromString","offsetSDR","offsetHDR","isArray","parseFloat","MPFExtractor","options","debug","undefined","extractFII","extractNonFII","extract","imageArrayBuffer","Promise","resolve","reject","dataView","DataView","buffer","getUint16","byteLength","offset","loops","marker","getUint8","log","formatPt","getUint32","tiffOffset","bigEnd","firstIFDOffset","dirStart","count","entriesStart","numberOfImages","i","nextIFDOffsetLen","MPImageListValPt","images","MPType","size","dataOffset","dependantImages","isFII","push","bufferBlob","Blob","imgs","imageBlob","extractGainmapFromJPEG","jpegFile","metadata","mpfExtractor","Uint8Array","arrayBuffer","getHTMLImageFromBlob","blob","img","document","createElement","onload","onerror","src","URL","createObjectURL","LoaderBase","manager","_renderer","_internalLoadingManager","setRenderer","setRenderTargetOptions","_renderTargetOptions","prepareQuadRenderer","sdrBuffer","gainMapBuffer","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","createImageBitmap","res","all","imageOrientation","ImageData","flipY","pow","GainMapLoader","load","_ref2","onLoad","onProgress","onError","sdrUrl","gainMapUrl","metadataUrl","loadCheck","error","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","total","loaded","lengthComputable","ProgressEvent","itemStart","sdrLoader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","gainMapLoader","metadataLoader","json","JSON","parse","HDRJPGLoader","url","loader","jpeg","jpegBuffer","sdrJPEG","gainMapJPEG","extractionResult","JPEGRLoader"],"sources":["C:/Users/admin/Desktop/All Custome Codes/BolbAnimation/Partical-Blob/node_modules/@react-three/drei/node_modules/@monogrid/gainmap-js/dist/decode.js"],"sourcesContent":["/**\r\n * @monogrid/gainmap-js v3.0.5\r\n * With ❤️, by MONOGRID <rnd@monogrid.com>\r\n */\r\n\r\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\r\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\r\n\r\nconst vertexShader = /* glsl */ `\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}\r\n`;\r\nconst fragmentShader = /* glsl */ `\r\n// min half float value\r\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\r\n// max half float value\r\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\r\n\r\nuniform sampler2D sdr;\r\nuniform sampler2D gainMap;\r\nuniform vec3 gamma;\r\nuniform vec3 offsetHdr;\r\nuniform vec3 offsetSdr;\r\nuniform vec3 gainMapMin;\r\nuniform vec3 gainMapMax;\r\nuniform float weightFactor;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\r\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\r\n  vec3 logRecovery = pow( recovery, gamma );\r\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\r\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\r\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\r\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\r\n}\r\n`;\r\n/**\r\n * A Material which is able to decode the Gainmap into a full HDR Representation\r\n *\r\n * @category Materials\r\n * @group Materials\r\n */\r\nclass GainMapDecoderMaterial extends ShaderMaterial {\r\n    /**\r\n     *\r\n     * @param params\r\n     */\r\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\r\n        super({\r\n            name: 'GainMapDecoderMaterial',\r\n            vertexShader,\r\n            fragmentShader,\r\n            uniforms: {\r\n                sdr: { value: sdr },\r\n                gainMap: { value: gainMap },\r\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\r\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\r\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\r\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\r\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\r\n                weightFactor: {\r\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\r\n                }\r\n            },\r\n            blending: NoBlending,\r\n            depthTest: false,\r\n            depthWrite: false\r\n        });\r\n        this._maxDisplayBoost = maxDisplayBoost;\r\n        this._hdrCapacityMin = hdrCapacityMin;\r\n        this._hdrCapacityMax = hdrCapacityMax;\r\n        this.needsUpdate = true;\r\n        this.uniformsNeedUpdate = true;\r\n    }\r\n    get sdr() { return this.uniforms.sdr.value; }\r\n    set sdr(value) { this.uniforms.sdr.value = value; }\r\n    get gainMap() { return this.uniforms.gainMap.value; }\r\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\r\n    /**\r\n     * @see {@link GainMapMetadata.offsetHdr}\r\n     */\r\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\r\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\r\n    /**\r\n     * @see {@link GainMapMetadata.offsetSdr}\r\n     */\r\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\r\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\r\n    /**\r\n     * @see {@link GainMapMetadata.gainMapMin}\r\n     */\r\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\r\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\r\n    /**\r\n     * @see {@link GainMapMetadata.gainMapMax}\r\n     */\r\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\r\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\r\n    /**\r\n     * @see {@link GainMapMetadata.gamma}\r\n     */\r\n    get gamma() {\r\n        const g = this.uniforms.gamma.value;\r\n        return [1 / g.x, 1 / g.y, 1 / g.z];\r\n    }\r\n    set gamma(value) {\r\n        const g = this.uniforms.gamma.value;\r\n        g.x = 1.0 / value[0];\r\n        g.y = 1.0 / value[1];\r\n        g.z = 1.0 / value[2];\r\n    }\r\n    /**\r\n     * @see {@link GainMapMetadata.hdrCapacityMin}\r\n     * @remarks Logarithmic space\r\n     */\r\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\r\n    set hdrCapacityMin(value) {\r\n        this._hdrCapacityMin = value;\r\n        this.calculateWeight();\r\n    }\r\n    /**\r\n     * @see {@link GainMapMetadata.hdrCapacityMin}\r\n     * @remarks Logarithmic space\r\n     */\r\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\r\n    set hdrCapacityMax(value) {\r\n        this._hdrCapacityMax = value;\r\n        this.calculateWeight();\r\n    }\r\n    /**\r\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\r\n     * @remarks Non Logarithmic space\r\n     */\r\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\r\n    set maxDisplayBoost(value) {\r\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\r\n        this.calculateWeight();\r\n    }\r\n    calculateWeight() {\r\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\r\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\r\n    }\r\n}\r\n\r\n/**\r\n * Decodes a gain map using a WebGLRenderTarget\r\n *\r\n * @category Decoding Functions\r\n * @group Decoding Functions\r\n * @example\r\n * import { decode } from '@monogrid/gainmap-js'\r\n * import {\r\n *   Mesh,\r\n *   MeshBasicMaterial,\r\n *   PerspectiveCamera,\r\n *   PlaneGeometry,\r\n *   Scene,\r\n *   TextureLoader,\r\n *   WebGLRenderer\r\n * } from 'three'\r\n *\r\n * const renderer = new WebGLRenderer()\r\n *\r\n * const textureLoader = new TextureLoader()\r\n *\r\n * // load SDR Representation\r\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\r\n * // load Gain map recovery image\r\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\r\n * // load metadata\r\n * const metadata = await (await fetch('metadata.json')).json()\r\n *\r\n * const result = await decode({\r\n *   sdr,\r\n *   gainMap,\r\n *   // this allows to use `result.renderTarget.texture` directly\r\n *   renderer,\r\n *   // this will restore the full HDR range\r\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\r\n *   ...metadata\r\n * })\r\n *\r\n * const scene = new Scene()\r\n * // `result` can be used to populate a Texture\r\n * const mesh = new Mesh(\r\n *   new PlaneGeometry(),\r\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\r\n * )\r\n * scene.add(mesh)\r\n * renderer.render(scene, new PerspectiveCamera())\r\n *\r\n * // result must be manually disposed\r\n * // when you are done using it\r\n * result.dispose()\r\n *\r\n * @param params\r\n * @returns\r\n * @throws {Error} if the WebGLRenderer fails to render the gain map\r\n */\r\nconst decode = (params) => {\r\n    const { sdr, gainMap, renderer } = params;\r\n    if (sdr.colorSpace !== SRGBColorSpace) {\r\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\r\n        sdr.colorSpace = SRGBColorSpace;\r\n    }\r\n    sdr.needsUpdate = true;\r\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\r\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\r\n        gainMap.colorSpace = LinearSRGBColorSpace;\r\n    }\r\n    gainMap.needsUpdate = true;\r\n    const material = new GainMapDecoderMaterial({\r\n        ...params,\r\n        sdr,\r\n        gainMap\r\n    });\r\n    const quadRenderer = new QuadRenderer({\r\n        // TODO: three types are generic, eslint complains here, see how we can solve\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\r\n        width: sdr.image.width,\r\n        // TODO: three types are generic, eslint complains here, see how we can solve\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\r\n        height: sdr.image.height,\r\n        type: HalfFloatType,\r\n        colorSpace: LinearSRGBColorSpace,\r\n        material,\r\n        renderer,\r\n        renderTargetOptions: params.renderTargetOptions\r\n    });\r\n    try {\r\n        quadRenderer.render();\r\n    }\r\n    catch (e) {\r\n        quadRenderer.disposeOnDemandRenderer();\r\n        throw e;\r\n    }\r\n    return quadRenderer;\r\n};\r\n\r\nclass GainMapNotFoundError extends Error {\r\n}\r\n\r\nclass XMPMetadataNotFoundError extends Error {\r\n}\r\n\r\nconst getAttribute = (description, name, defaultValue) => {\r\n    var _a;\r\n    let returnValue;\r\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\r\n    if (!parsedValue) {\r\n        const node = description.getElementsByTagName(name)[0];\r\n        if (node) {\r\n            const values = node.getElementsByTagName('rdf:li');\r\n            if (values.length === 3) {\r\n                returnValue = Array.from(values).map(v => v.innerHTML);\r\n            }\r\n            else {\r\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\r\n            }\r\n        }\r\n        else {\r\n            if (defaultValue)\r\n                return defaultValue;\r\n            else\r\n                throw new Error(`Can't find ${name} in gainmap metadata`);\r\n        }\r\n    }\r\n    else {\r\n        returnValue = parsedValue;\r\n    }\r\n    return returnValue;\r\n};\r\n/**\r\n *\r\n * @param input\r\n * @returns\r\n */\r\nconst extractXMP = (input) => {\r\n    var _a, _b;\r\n    let str;\r\n    // support node test environment\r\n    if (typeof TextDecoder !== 'undefined')\r\n        str = new TextDecoder().decode(input);\r\n    else\r\n        str = input.toString();\r\n    let start = str.indexOf('<x:xmpmeta');\r\n    const parser = new DOMParser();\r\n    while (start !== -1) {\r\n        const end = str.indexOf('x:xmpmeta>', start);\r\n        str.slice(start, end + 10);\r\n        const xmpBlock = str.slice(start, end + 10);\r\n        try {\r\n            const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\r\n            const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\r\n            const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\r\n            const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\r\n            const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\r\n            const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\r\n            const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\r\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\r\n            if (!hdrCapacityMin)\r\n                hdrCapacityMin = '0';\r\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\r\n            if (!hdrCapacityMax)\r\n                throw new Error('Incomplete gainmap metadata');\r\n            return {\r\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\r\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\r\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\r\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\r\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\r\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\r\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\r\n            };\r\n        }\r\n        catch (e) {\r\n        }\r\n        start = str.indexOf('<x:xmpmeta', end);\r\n    }\r\n};\r\n\r\n/**\r\n * MPF Extractor (Multi Picture Format Extractor)\r\n * By Henrik S Nilsson 2019\r\n *\r\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\r\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\r\n *\r\n * Overly commented, and without intention of being complete or production ready.\r\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\r\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\r\n */\r\nclass MPFExtractor {\r\n    constructor(options) {\r\n        this.options = {\r\n            debug: options && options.debug !== undefined ? options.debug : false,\r\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\r\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\r\n        };\r\n    }\r\n    extract(imageArrayBuffer) {\r\n        return new Promise((resolve, reject) => {\r\n            const debug = this.options.debug;\r\n            const dataView = new DataView(imageArrayBuffer.buffer);\r\n            // If you're executing this line on a big endian machine, it'll be reversed.\r\n            // bigEnd further down though, refers to the endianness of the image itself.\r\n            if (dataView.getUint16(0) !== 0xffd8) {\r\n                reject(new Error('Not a valid jpeg'));\r\n                return;\r\n            }\r\n            const length = dataView.byteLength;\r\n            let offset = 2;\r\n            let loops = 0;\r\n            let marker; // APP# marker\r\n            while (offset < length) {\r\n                if (++loops > 250) {\r\n                    reject(new Error(`Found no marker after ${loops} loops 😵`));\r\n                    return;\r\n                }\r\n                if (dataView.getUint8(offset) !== 0xff) {\r\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\r\n                    return;\r\n                }\r\n                marker = dataView.getUint8(offset + 1);\r\n                if (debug)\r\n                    console.log(`Marker: ${marker.toString(16)}`);\r\n                if (marker === 0xe2) {\r\n                    if (debug)\r\n                        console.log('Found APP2 marker (0xffe2)');\r\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\r\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\r\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\r\n                    const formatPt = offset + 4;\r\n                    /*\r\n                     *  Structure of the MP Format Identifier\r\n                     *\r\n                     *  Offset Addr.  | Code (Hex)  | Description\r\n                     *  +00             ff            Marker Prefix      <-- offset\r\n                     *  +01             e2            APP2\r\n                     *  +02             #n            APP2 Field Length\r\n                     *  +03             #n            APP2 Field Length\r\n                     *  +04             4d            'M'                <-- formatPt\r\n                     *  +05             50            'P'\r\n                     *  +06             46            'F'\r\n                     *  +07             00            NULL\r\n                     *                                                   <-- tiffOffset\r\n                     */\r\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\r\n                        // Found MPF tag, so we start dig out sub images\r\n                        const tiffOffset = formatPt + 4;\r\n                        let bigEnd; // Endianness from TIFF header\r\n                        // Test for TIFF validity and endianness\r\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\r\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\r\n                            bigEnd = false;\r\n                        }\r\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\r\n                            bigEnd = true;\r\n                        }\r\n                        else {\r\n                            reject(new Error('No valid endianness marker found in TIFF header'));\r\n                            return;\r\n                        }\r\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\r\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\r\n                            return;\r\n                        }\r\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\r\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\r\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\r\n                        if (firstIFDOffset < 0x00000008) {\r\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\r\n                            return;\r\n                        }\r\n                        // Move ahead to MP Index IFD\r\n                        // Assume we're at the first IFD, so firstIFDOffset points to\r\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\r\n                        // we fail silently here due to this assumption)\r\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\r\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\r\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\r\n                        // Extract info from MPEntries (starting after Count)\r\n                        const entriesStart = dirStart + 2;\r\n                        let numberOfImages = 0;\r\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\r\n                            // Each entry is 12 Bytes long\r\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\r\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\r\n                                // stored in Last 4 bytes of its 12 Byte entry.\r\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\r\n                            }\r\n                        }\r\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\r\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\r\n                        const images = [];\r\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\r\n                            const image = {\r\n                                MPType: dataView.getUint32(i, !bigEnd),\r\n                                size: dataView.getUint32(i + 4, !bigEnd),\r\n                                // This offset is specified relative to the address of the MP Endian\r\n                                // field in the MP Header, unless the image is a First Individual Image,\r\n                                // in which case the value of the offset shall be NULL (0x00000000).\r\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\r\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\r\n                                start: -1,\r\n                                end: -1,\r\n                                isFII: false\r\n                            };\r\n                            if (!image.dataOffset) {\r\n                                // dataOffset is 0x00000000 for First Individual Image\r\n                                image.start = 0;\r\n                                image.isFII = true;\r\n                            }\r\n                            else {\r\n                                image.start = tiffOffset + image.dataOffset;\r\n                                image.isFII = false;\r\n                            }\r\n                            image.end = image.start + image.size;\r\n                            images.push(image);\r\n                        }\r\n                        if (this.options.extractNonFII && images.length) {\r\n                            const bufferBlob = new Blob([dataView]);\r\n                            const imgs = [];\r\n                            for (const image of images) {\r\n                                if (image.isFII && !this.options.extractFII) {\r\n                                    continue; // Skip FII\r\n                                }\r\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\r\n                                // we don't need this\r\n                                // const imageUrl = URL.createObjectURL(imageBlob)\r\n                                // image.img = document.createElement('img')\r\n                                // image.img.src = imageUrl\r\n                                imgs.push(imageBlob);\r\n                            }\r\n                            resolve(imgs);\r\n                        }\r\n                    }\r\n                }\r\n                offset += 2 + dataView.getUint16(offset + 2);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Extracts XMP Metadata and the gain map recovery image\r\n * from a single JPEG file.\r\n *\r\n * @category Decoding Functions\r\n * @group Decoding Functions\r\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\r\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\r\n * @throws Error if XMP Metadata is not found\r\n * @throws Error if Gain map image is not found\r\n * @example\r\n * import { FileLoader } from 'three'\r\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\r\n *\r\n * const jpegFile = await new FileLoader()\r\n *  .setResponseType('arraybuffer')\r\n *  .loadAsync('image.jpg')\r\n *\r\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\r\n */\r\nconst extractGainmapFromJPEG = async (jpegFile) => {\r\n    const metadata = extractXMP(jpegFile);\r\n    if (!metadata)\r\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\r\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\r\n    const images = await mpfExtractor.extract(jpegFile);\r\n    if (images.length !== 2)\r\n        throw new GainMapNotFoundError('Gain map recovery image not found');\r\n    return {\r\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\r\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\r\n        metadata\r\n    };\r\n};\r\n\r\n/**\r\n * private function, async get image from blob\r\n *\r\n * @param blob\r\n * @returns\r\n */\r\nconst getHTMLImageFromBlob = (blob) => {\r\n    return new Promise((resolve, reject) => {\r\n        const img = document.createElement('img');\r\n        img.onload = () => { resolve(img); };\r\n        img.onerror = (e) => { reject(e); };\r\n        img.src = URL.createObjectURL(blob);\r\n    });\r\n};\r\n\r\nclass LoaderBase extends Loader {\r\n    /**\r\n     *\r\n     * @param renderer\r\n     * @param manager\r\n     */\r\n    constructor(renderer, manager) {\r\n        super(manager);\r\n        if (renderer)\r\n            this._renderer = renderer;\r\n        this._internalLoadingManager = new LoadingManager();\r\n    }\r\n    /**\r\n     * Specify the renderer to use when rendering the gain map\r\n     *\r\n     * @param renderer\r\n     * @returns\r\n     */\r\n    setRenderer(renderer) {\r\n        this._renderer = renderer;\r\n        return this;\r\n    }\r\n    /**\r\n     * Specify the renderTarget options to use when rendering the gain map\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    setRenderTargetOptions(options) {\r\n        this._renderTargetOptions = options;\r\n        return this;\r\n    }\r\n    /**\r\n     * @private\r\n     * @returns\r\n     */\r\n    prepareQuadRenderer() {\r\n        if (!this._renderer)\r\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\r\n        // temporary values\r\n        const material = new GainMapDecoderMaterial({\r\n            gainMapMax: [1, 1, 1],\r\n            gainMapMin: [0, 0, 0],\r\n            gamma: [1, 1, 1],\r\n            offsetHdr: [1, 1, 1],\r\n            offsetSdr: [1, 1, 1],\r\n            hdrCapacityMax: 1,\r\n            hdrCapacityMin: 0,\r\n            maxDisplayBoost: 1,\r\n            gainMap: new Texture(),\r\n            sdr: new Texture()\r\n        });\r\n        return new QuadRenderer({\r\n            width: 16,\r\n            height: 16,\r\n            type: HalfFloatType,\r\n            colorSpace: LinearSRGBColorSpace,\r\n            material,\r\n            renderer: this._renderer,\r\n            renderTargetOptions: this._renderTargetOptions\r\n        });\r\n    }\r\n    /**\r\n   * @private\r\n   * @param quadRenderer\r\n   * @param metadata\r\n   * @param sdrBuffer\r\n   * @param gainMapBuffer\r\n   */\r\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\r\n        // this is optional, will render a black gain-map if not present\r\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\r\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\r\n        let sdrImage;\r\n        let gainMapImage;\r\n        let needsFlip = false;\r\n        if (typeof createImageBitmap === 'undefined') {\r\n            const res = await Promise.all([\r\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\r\n                getHTMLImageFromBlob(sdrBlob)\r\n            ]);\r\n            gainMapImage = res[0];\r\n            sdrImage = res[1];\r\n            needsFlip = true;\r\n        }\r\n        else {\r\n            const res = await Promise.all([\r\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\r\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\r\n            ]);\r\n            gainMapImage = res[0];\r\n            sdrImage = res[1];\r\n        }\r\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\r\n        gainMap.flipY = needsFlip;\r\n        gainMap.needsUpdate = true;\r\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\r\n        sdr.flipY = needsFlip;\r\n        sdr.needsUpdate = true;\r\n        quadRenderer.width = sdrImage.width;\r\n        quadRenderer.height = sdrImage.height;\r\n        quadRenderer.material.gainMap = gainMap;\r\n        quadRenderer.material.sdr = sdr;\r\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\r\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\r\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\r\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\r\n        quadRenderer.material.gamma = metadata.gamma;\r\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\r\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\r\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\r\n        quadRenderer.material.needsUpdate = true;\r\n        quadRenderer.render();\r\n    }\r\n}\r\n\r\n/**\r\n * A Three.js Loader for the gain map format.\r\n *\r\n * @category Loaders\r\n * @group Loaders\r\n *\r\n * @example\r\n * import { GainMapLoader } from '@monogrid/gainmap-js'\r\n * import {\r\n *   EquirectangularReflectionMapping,\r\n *   LinearFilter,\r\n *   Mesh,\r\n *   MeshBasicMaterial,\r\n *   PerspectiveCamera,\r\n *   PlaneGeometry,\r\n *   Scene,\r\n *   WebGLRenderer\r\n * } from 'three'\r\n *\r\n * const renderer = new WebGLRenderer()\r\n *\r\n * const loader = new GainMapLoader(renderer)\r\n *\r\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\r\n * // `result` can be used to populate a Texture\r\n *\r\n * const scene = new Scene()\r\n * const mesh = new Mesh(\r\n *   new PlaneGeometry(),\r\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\r\n * )\r\n * scene.add(mesh)\r\n * renderer.render(scene, new PerspectiveCamera())\r\n *\r\n * // Starting from three.js r159\r\n * // `result.renderTarget.texture` can\r\n * // also be used as Equirectangular scene background\r\n * //\r\n * // it was previously needed to convert it\r\n * // to a DataTexture with `result.toDataTexture()`\r\n * scene.background = result.renderTarget.texture\r\n * scene.background.mapping = EquirectangularReflectionMapping\r\n *\r\n * // result must be manually disposed\r\n * // when you are done using it\r\n * result.dispose()\r\n *\r\n */\r\nclass GainMapLoader extends LoaderBase {\r\n    /**\r\n     * Loads a gainmap using separate data\r\n     * * sdr image\r\n     * * gain map image\r\n     * * metadata json\r\n     *\r\n     * useful for webp gain maps\r\n     *\r\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\r\n     * @param onLoad Load complete callback, will receive the result\r\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\r\n     * @param onError Error callback\r\n     * @returns\r\n     */\r\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\r\n        const quadRenderer = this.prepareQuadRenderer();\r\n        let sdr;\r\n        let gainMap;\r\n        let metadata;\r\n        const loadCheck = async () => {\r\n            if (sdr && gainMap && metadata) {\r\n                // solves #16\r\n                try {\r\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\r\n                }\r\n                catch (error) {\r\n                    this.manager.itemError(sdrUrl);\r\n                    this.manager.itemError(gainMapUrl);\r\n                    this.manager.itemError(metadataUrl);\r\n                    if (typeof onError === 'function')\r\n                        onError(error);\r\n                    quadRenderer.disposeOnDemandRenderer();\r\n                    return;\r\n                }\r\n                if (typeof onLoad === 'function')\r\n                    onLoad(quadRenderer);\r\n                this.manager.itemEnd(sdrUrl);\r\n                this.manager.itemEnd(gainMapUrl);\r\n                this.manager.itemEnd(metadataUrl);\r\n                quadRenderer.disposeOnDemandRenderer();\r\n            }\r\n        };\r\n        let sdrLengthComputable = true;\r\n        let sdrTotal = 0;\r\n        let sdrLoaded = 0;\r\n        let gainMapLengthComputable = true;\r\n        let gainMapTotal = 0;\r\n        let gainMapLoaded = 0;\r\n        let metadataLengthComputable = true;\r\n        let metadataTotal = 0;\r\n        let metadataLoaded = 0;\r\n        const progressHandler = () => {\r\n            if (typeof onProgress === 'function') {\r\n                const total = sdrTotal + gainMapTotal + metadataTotal;\r\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\r\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\r\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\r\n            }\r\n        };\r\n        this.manager.itemStart(sdrUrl);\r\n        this.manager.itemStart(gainMapUrl);\r\n        this.manager.itemStart(metadataUrl);\r\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\r\n        sdrLoader.setResponseType('arraybuffer');\r\n        sdrLoader.setRequestHeader(this.requestHeader);\r\n        sdrLoader.setPath(this.path);\r\n        sdrLoader.setWithCredentials(this.withCredentials);\r\n        sdrLoader.load(sdrUrl, async (buffer) => {\r\n            /* istanbul ignore if\r\n             this condition exists only because of three.js types + strict mode\r\n            */\r\n            if (typeof buffer === 'string')\r\n                throw new Error('Invalid sdr buffer');\r\n            sdr = buffer;\r\n            await loadCheck();\r\n        }, (e) => {\r\n            sdrLengthComputable = e.lengthComputable;\r\n            sdrLoaded = e.loaded;\r\n            sdrTotal = e.total;\r\n            progressHandler();\r\n        }, (error) => {\r\n            this.manager.itemError(sdrUrl);\r\n            if (typeof onError === 'function')\r\n                onError(error);\r\n        });\r\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\r\n        gainMapLoader.setResponseType('arraybuffer');\r\n        gainMapLoader.setRequestHeader(this.requestHeader);\r\n        gainMapLoader.setPath(this.path);\r\n        gainMapLoader.setWithCredentials(this.withCredentials);\r\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\r\n            /* istanbul ignore if\r\n             this condition exists only because of three.js types + strict mode\r\n            */\r\n            if (typeof buffer === 'string')\r\n                throw new Error('Invalid gainmap buffer');\r\n            gainMap = buffer;\r\n            await loadCheck();\r\n        }, (e) => {\r\n            gainMapLengthComputable = e.lengthComputable;\r\n            gainMapLoaded = e.loaded;\r\n            gainMapTotal = e.total;\r\n            progressHandler();\r\n        }, (error) => {\r\n            this.manager.itemError(gainMapUrl);\r\n            if (typeof onError === 'function')\r\n                onError(error);\r\n        });\r\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\r\n        // metadataLoader.setResponseType('json')\r\n        metadataLoader.setRequestHeader(this.requestHeader);\r\n        metadataLoader.setPath(this.path);\r\n        metadataLoader.setWithCredentials(this.withCredentials);\r\n        metadataLoader.load(metadataUrl, async (json) => {\r\n            /* istanbul ignore if\r\n             this condition exists only because of three.js types + strict mode\r\n            */\r\n            if (typeof json !== 'string')\r\n                throw new Error('Invalid metadata string');\r\n            // TODO: implement check on JSON file and remove this eslint disable\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n            metadata = JSON.parse(json);\r\n            await loadCheck();\r\n        }, (e) => {\r\n            metadataLengthComputable = e.lengthComputable;\r\n            metadataLoaded = e.loaded;\r\n            metadataTotal = e.total;\r\n            progressHandler();\r\n        }, (error) => {\r\n            this.manager.itemError(metadataUrl);\r\n            if (typeof onError === 'function')\r\n                onError(error);\r\n        });\r\n        return quadRenderer;\r\n    }\r\n}\r\n\r\n/**\r\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\r\n *\r\n * @category Loaders\r\n * @group Loaders\r\n *\r\n * @example\r\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\r\n * import {\r\n *   EquirectangularReflectionMapping,\r\n *   LinearFilter,\r\n *   Mesh,\r\n *   MeshBasicMaterial,\r\n *   PerspectiveCamera,\r\n *   PlaneGeometry,\r\n *   Scene,\r\n *   WebGLRenderer\r\n * } from 'three'\r\n *\r\n * const renderer = new WebGLRenderer()\r\n *\r\n * const loader = new HDRJPGLoader(renderer)\r\n *\r\n * const result = await loader.loadAsync('gainmap.jpeg')\r\n * // `result` can be used to populate a Texture\r\n *\r\n * const scene = new Scene()\r\n * const mesh = new Mesh(\r\n *   new PlaneGeometry(),\r\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\r\n * )\r\n * scene.add(mesh)\r\n * renderer.render(scene, new PerspectiveCamera())\r\n *\r\n * // Starting from three.js r159\r\n * // `result.renderTarget.texture` can\r\n * // also be used as Equirectangular scene background\r\n * //\r\n * // it was previously needed to convert it\r\n * // to a DataTexture with `result.toDataTexture()`\r\n * scene.background = result.renderTarget.texture\r\n * scene.background.mapping = EquirectangularReflectionMapping\r\n *\r\n * // result must be manually disposed\r\n * // when you are done using it\r\n * result.dispose()\r\n *\r\n */\r\nclass HDRJPGLoader extends LoaderBase {\r\n    /**\r\n     * Loads a JPEG containing gain map metadata\r\n     * Renders a normal SDR image if gainmap data is not found\r\n     *\r\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\r\n     * @param onLoad Load complete callback, will receive the result\r\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\r\n     * @param onError Error callback\r\n     * @returns\r\n     */\r\n    load(url, onLoad, onProgress, onError) {\r\n        const quadRenderer = this.prepareQuadRenderer();\r\n        const loader = new FileLoader(this._internalLoadingManager);\r\n        loader.setResponseType('arraybuffer');\r\n        loader.setRequestHeader(this.requestHeader);\r\n        loader.setPath(this.path);\r\n        loader.setWithCredentials(this.withCredentials);\r\n        this.manager.itemStart(url);\r\n        loader.load(url, async (jpeg) => {\r\n            /* istanbul ignore if\r\n             this condition exists only because of three.js types + strict mode\r\n            */\r\n            if (typeof jpeg === 'string')\r\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\r\n            const jpegBuffer = new Uint8Array(jpeg);\r\n            let sdrJPEG;\r\n            let gainMapJPEG;\r\n            let metadata;\r\n            try {\r\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\r\n                // gain map is successfully reconstructed\r\n                sdrJPEG = extractionResult.sdr;\r\n                gainMapJPEG = extractionResult.gainMap;\r\n                metadata = extractionResult.metadata;\r\n            }\r\n            catch (e) {\r\n                // render the SDR version if this is not a gainmap\r\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\r\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\r\n                    metadata = {\r\n                        gainMapMin: [0, 0, 0],\r\n                        gainMapMax: [1, 1, 1],\r\n                        gamma: [1, 1, 1],\r\n                        hdrCapacityMin: 0,\r\n                        hdrCapacityMax: 1,\r\n                        offsetHdr: [0, 0, 0],\r\n                        offsetSdr: [0, 0, 0]\r\n                    };\r\n                    sdrJPEG = jpegBuffer;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n            // solves #16\r\n            try {\r\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\r\n            }\r\n            catch (error) {\r\n                this.manager.itemError(url);\r\n                if (typeof onError === 'function')\r\n                    onError(error);\r\n                quadRenderer.disposeOnDemandRenderer();\r\n                return;\r\n            }\r\n            if (typeof onLoad === 'function')\r\n                onLoad(quadRenderer);\r\n            this.manager.itemEnd(url);\r\n            quadRenderer.disposeOnDemandRenderer();\r\n        }, onProgress, (error) => {\r\n            this.manager.itemError(url);\r\n            if (typeof onError === 'function')\r\n                onError(error);\r\n        });\r\n        return quadRenderer;\r\n    }\r\n}\r\n\r\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,SAASA,CAAC,IAAIC,YAAY,QAAQ,4BAA4B;AAC9D,SAASC,cAAc,EAAEC,OAAO,EAAEC,UAAU,EAAEC,cAAc,EAAEC,oBAAoB,EAAEC,aAAa,EAAEC,MAAM,EAAEC,cAAc,EAAEC,OAAO,EAAEC,SAAS,EAAEC,mBAAmB,EAAEC,YAAY,EAAEC,wBAAwB,EAAEC,UAAU,EAAEC,gBAAgB,EAAEC,UAAU,QAAQ,OAAO;AAEnQ,MAAMC,YAAY,GAAG,6IAOpB;AACD,MAAMC,cAAc,GAAG,m1BA0BtB;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,sBAAsB,SAASlB,cAAc,CAAC;EAChD;AACJ;AACA;AACA;EACImB,WAAWA,CAAAC,IAAA,EAAyH;IAAA,IAAxH;MAAEC,KAAK;MAAEC,SAAS;MAAEC,SAAS;MAAEC,UAAU;MAAEC,UAAU;MAAEC,eAAe;MAAEC,cAAc;MAAEC,cAAc;MAAEC,GAAG;MAAEC;IAAQ,CAAC,GAAAV,IAAA;IAC9H,KAAK,CAAC;MACFW,IAAI,EAAE,wBAAwB;MAC9Bf,YAAY;MACZC,cAAc;MACde,QAAQ,EAAE;QACNH,GAAG,EAAE;UAAEI,KAAK,EAAEJ;QAAI,CAAC;QACnBC,OAAO,EAAE;UAAEG,KAAK,EAAEH;QAAQ,CAAC;QAC3BT,KAAK,EAAE;UAAEY,KAAK,EAAE,IAAIhC,OAAO,CAAC,GAAG,GAAGoB,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,GAAGA,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,GAAGA,KAAK,CAAC,CAAC,CAAC;QAAE,CAAC;QAC7EC,SAAS,EAAE;UAAEW,KAAK,EAAE,IAAIhC,OAAO,CAAC,CAAC,CAACiC,SAAS,CAACZ,SAAS;QAAE,CAAC;QACxDC,SAAS,EAAE;UAAEU,KAAK,EAAE,IAAIhC,OAAO,CAAC,CAAC,CAACiC,SAAS,CAACX,SAAS;QAAE,CAAC;QACxDC,UAAU,EAAE;UAAES,KAAK,EAAE,IAAIhC,OAAO,CAAC,CAAC,CAACiC,SAAS,CAACV,UAAU;QAAE,CAAC;QAC1DC,UAAU,EAAE;UAAEQ,KAAK,EAAE,IAAIhC,OAAO,CAAC,CAAC,CAACiC,SAAS,CAACT,UAAU;QAAE,CAAC;QAC1DU,YAAY,EAAE;UACVF,KAAK,EAAE,CAACG,IAAI,CAACC,IAAI,CAACX,eAAe,CAAC,GAAGC,cAAc,KAAKC,cAAc,GAAGD,cAAc;QAC3F;MACJ,CAAC;MACDW,QAAQ,EAAEpC,UAAU;MACpBqC,SAAS,EAAE,KAAK;MAChBC,UAAU,EAAE;IAChB,CAAC,CAAC;IACF,IAAI,CAACC,gBAAgB,GAAGf,eAAe;IACvC,IAAI,CAACgB,eAAe,GAAGf,cAAc;IACrC,IAAI,CAACgB,eAAe,GAAGf,cAAc;IACrC,IAAI,CAACgB,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,kBAAkB,GAAG,IAAI;EAClC;EACA,IAAIhB,GAAGA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACG,QAAQ,CAACH,GAAG,CAACI,KAAK;EAAE;EAC5C,IAAIJ,GAAGA,CAACI,KAAK,EAAE;IAAE,IAAI,CAACD,QAAQ,CAACH,GAAG,CAACI,KAAK,GAAGA,KAAK;EAAE;EAClD,IAAIH,OAAOA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACE,QAAQ,CAACF,OAAO,CAACG,KAAK;EAAE;EACpD,IAAIH,OAAOA,CAACG,KAAK,EAAE;IAAE,IAAI,CAACD,QAAQ,CAACF,OAAO,CAACG,KAAK,GAAGA,KAAK;EAAE;EAC1D;AACJ;AACA;EACI,IAAIX,SAASA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACU,QAAQ,CAACV,SAAS,CAACW,KAAK,CAACa,OAAO,CAAC,CAAC;EAAE;EAClE,IAAIxB,SAASA,CAACW,KAAK,EAAE;IAAE,IAAI,CAACD,QAAQ,CAACV,SAAS,CAACW,KAAK,CAACC,SAAS,CAACD,KAAK,CAAC;EAAE;EACvE;AACJ;AACA;EACI,IAAIV,SAASA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACS,QAAQ,CAACT,SAAS,CAACU,KAAK,CAACa,OAAO,CAAC,CAAC;EAAE;EAClE,IAAIvB,SAASA,CAACU,KAAK,EAAE;IAAE,IAAI,CAACD,QAAQ,CAACT,SAAS,CAACU,KAAK,CAACC,SAAS,CAACD,KAAK,CAAC;EAAE;EACvE;AACJ;AACA;EACI,IAAIT,UAAUA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACQ,QAAQ,CAACR,UAAU,CAACS,KAAK,CAACa,OAAO,CAAC,CAAC;EAAE;EACpE,IAAItB,UAAUA,CAACS,KAAK,EAAE;IAAE,IAAI,CAACD,QAAQ,CAACR,UAAU,CAACS,KAAK,CAACC,SAAS,CAACD,KAAK,CAAC;EAAE;EACzE;AACJ;AACA;EACI,IAAIR,UAAUA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACO,QAAQ,CAACP,UAAU,CAACQ,KAAK,CAACa,OAAO,CAAC,CAAC;EAAE;EACpE,IAAIrB,UAAUA,CAACQ,KAAK,EAAE;IAAE,IAAI,CAACD,QAAQ,CAACP,UAAU,CAACQ,KAAK,CAACC,SAAS,CAACD,KAAK,CAAC;EAAE;EACzE;AACJ;AACA;EACI,IAAIZ,KAAKA,CAAA,EAAG;IACR,MAAM0B,CAAC,GAAG,IAAI,CAACf,QAAQ,CAACX,KAAK,CAACY,KAAK;IACnC,OAAO,CAAC,CAAC,GAAGc,CAAC,CAACC,CAAC,EAAE,CAAC,GAAGD,CAAC,CAACE,CAAC,EAAE,CAAC,GAAGF,CAAC,CAACG,CAAC,CAAC;EACtC;EACA,IAAI7B,KAAKA,CAACY,KAAK,EAAE;IACb,MAAMc,CAAC,GAAG,IAAI,CAACf,QAAQ,CAACX,KAAK,CAACY,KAAK;IACnCc,CAAC,CAACC,CAAC,GAAG,GAAG,GAAGf,KAAK,CAAC,CAAC,CAAC;IACpBc,CAAC,CAACE,CAAC,GAAG,GAAG,GAAGhB,KAAK,CAAC,CAAC,CAAC;IACpBc,CAAC,CAACG,CAAC,GAAG,GAAG,GAAGjB,KAAK,CAAC,CAAC,CAAC;EACxB;EACA;AACJ;AACA;AACA;EACI,IAAIN,cAAcA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACe,eAAe;EAAE;EACpD,IAAIf,cAAcA,CAACM,KAAK,EAAE;IACtB,IAAI,CAACS,eAAe,GAAGT,KAAK;IAC5B,IAAI,CAACkB,eAAe,CAAC,CAAC;EAC1B;EACA;AACJ;AACA;AACA;EACI,IAAIvB,cAAcA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACe,eAAe;EAAE;EACpD,IAAIf,cAAcA,CAACK,KAAK,EAAE;IACtB,IAAI,CAACU,eAAe,GAAGV,KAAK;IAC5B,IAAI,CAACkB,eAAe,CAAC,CAAC;EAC1B;EACA;AACJ;AACA;AACA;EACI,IAAIzB,eAAeA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACe,gBAAgB;EAAE;EACtD,IAAIf,eAAeA,CAACO,KAAK,EAAE;IACvB,IAAI,CAACQ,gBAAgB,GAAGL,IAAI,CAACgB,GAAG,CAAC,CAAC,EAAEhB,IAAI,CAACiB,GAAG,CAAC,KAAK,EAAEpB,KAAK,CAAC,CAAC;IAC3D,IAAI,CAACkB,eAAe,CAAC,CAAC;EAC1B;EACAA,eAAeA,CAAA,EAAG;IACd,MAAMG,GAAG,GAAG,CAAClB,IAAI,CAACC,IAAI,CAAC,IAAI,CAACI,gBAAgB,CAAC,GAAG,IAAI,CAACC,eAAe,KAAK,IAAI,CAACC,eAAe,GAAG,IAAI,CAACD,eAAe,CAAC;IACrH,IAAI,CAACV,QAAQ,CAACG,YAAY,CAACF,KAAK,GAAGG,IAAI,CAACgB,GAAG,CAAC,CAAC,EAAEhB,IAAI,CAACiB,GAAG,CAAC,CAAC,EAAEC,GAAG,CAAC,CAAC;EACpE;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAIC,MAAM,IAAK;EACvB,MAAM;IAAE3B,GAAG;IAAEC,OAAO;IAAE2B;EAAS,CAAC,GAAGD,MAAM;EACzC,IAAI3B,GAAG,CAAC6B,UAAU,KAAKvD,cAAc,EAAE;IACnCwD,OAAO,CAACC,IAAI,CAAC,uEAAuE,CAAC;IACrF/B,GAAG,CAAC6B,UAAU,GAAGvD,cAAc;EACnC;EACA0B,GAAG,CAACe,WAAW,GAAG,IAAI;EACtB,IAAId,OAAO,CAAC4B,UAAU,KAAKtD,oBAAoB,EAAE;IAC7CuD,OAAO,CAACC,IAAI,CAAC,iFAAiF,CAAC;IAC/F9B,OAAO,CAAC4B,UAAU,GAAGtD,oBAAoB;EAC7C;EACA0B,OAAO,CAACc,WAAW,GAAG,IAAI;EAC1B,MAAMiB,QAAQ,GAAG,IAAI3C,sBAAsB,CAAC;IACxC,GAAGsC,MAAM;IACT3B,GAAG;IACHC;EACJ,CAAC,CAAC;EACF,MAAMgC,YAAY,GAAG,IAAI/D,YAAY,CAAC;IAClC;IACA;IACAgE,KAAK,EAAElC,GAAG,CAACmC,KAAK,CAACD,KAAK;IACtB;IACA;IACAE,MAAM,EAAEpC,GAAG,CAACmC,KAAK,CAACC,MAAM;IACxBC,IAAI,EAAE7D,aAAa;IACnBqD,UAAU,EAAEtD,oBAAoB;IAChCyD,QAAQ;IACRJ,QAAQ;IACRU,mBAAmB,EAAEX,MAAM,CAACW;EAChC,CAAC,CAAC;EACF,IAAI;IACAL,YAAY,CAACM,MAAM,CAAC,CAAC;EACzB,CAAC,CACD,OAAOC,CAAC,EAAE;IACNP,YAAY,CAACQ,uBAAuB,CAAC,CAAC;IACtC,MAAMD,CAAC;EACX;EACA,OAAOP,YAAY;AACvB,CAAC;AAED,MAAMS,oBAAoB,SAASC,KAAK,CAAC;AAGzC,MAAMC,wBAAwB,SAASD,KAAK,CAAC;AAG7C,MAAME,YAAY,GAAGA,CAACC,WAAW,EAAE5C,IAAI,EAAE6C,YAAY,KAAK;EACtD,IAAIC,EAAE;EACN,IAAIC,WAAW;EACf,MAAMC,WAAW,GAAG,CAACF,EAAE,GAAGF,WAAW,CAACK,UAAU,CAACC,YAAY,CAAClD,IAAI,CAAC,MAAM,IAAI,IAAI8C,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,SAAS;EACtH,IAAI,CAACH,WAAW,EAAE;IACd,MAAMI,IAAI,GAAGR,WAAW,CAACS,oBAAoB,CAACrD,IAAI,CAAC,CAAC,CAAC,CAAC;IACtD,IAAIoD,IAAI,EAAE;MACN,MAAME,MAAM,GAAGF,IAAI,CAACC,oBAAoB,CAAC,QAAQ,CAAC;MAClD,IAAIC,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;QACrBR,WAAW,GAAGS,KAAK,CAACC,IAAI,CAACH,MAAM,CAAC,CAACI,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,SAAS,CAAC;MAC1D,CAAC,MACI;QACD,MAAM,IAAInB,KAAK,oDAAAoB,MAAA,CAAoD7D,IAAI,6BAA0B,CAAC;MACtG;IACJ,CAAC,MACI;MACD,IAAI6C,YAAY,EACZ,OAAOA,YAAY,CAAC,KAEpB,MAAM,IAAIJ,KAAK,eAAAoB,MAAA,CAAe7D,IAAI,yBAAsB,CAAC;IACjE;EACJ,CAAC,MACI;IACD+C,WAAW,GAAGC,WAAW;EAC7B;EACA,OAAOD,WAAW;AACtB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,MAAMe,UAAU,GAAIC,KAAK,IAAK;EAC1B,IAAIjB,EAAE,EAAEkB,EAAE;EACV,IAAIC,GAAG;EACP;EACA,IAAI,OAAOC,WAAW,KAAK,WAAW,EAClCD,GAAG,GAAG,IAAIC,WAAW,CAAC,CAAC,CAAC1C,MAAM,CAACuC,KAAK,CAAC,CAAC,KAEtCE,GAAG,GAAGF,KAAK,CAACI,QAAQ,CAAC,CAAC;EAC1B,IAAIC,KAAK,GAAGH,GAAG,CAACI,OAAO,CAAC,YAAY,CAAC;EACrC,MAAMC,MAAM,GAAG,IAAIC,SAAS,CAAC,CAAC;EAC9B,OAAOH,KAAK,KAAK,CAAC,CAAC,EAAE;IACjB,MAAMI,GAAG,GAAGP,GAAG,CAACI,OAAO,CAAC,YAAY,EAAED,KAAK,CAAC;IAC5CH,GAAG,CAACQ,KAAK,CAACL,KAAK,EAAEI,GAAG,GAAG,EAAE,CAAC;IAC1B,MAAME,QAAQ,GAAGT,GAAG,CAACQ,KAAK,CAACL,KAAK,EAAEI,GAAG,GAAG,EAAE,CAAC;IAC3C,IAAI;MACA,MAAMG,WAAW,GAAGL,MAAM,CAACM,eAAe,CAACF,QAAQ,EAAE,UAAU,CAAC;MAChE,MAAM9B,WAAW,GAAG+B,WAAW,CAACtB,oBAAoB,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;MAC1E,MAAM5D,UAAU,GAAGkD,YAAY,CAACC,WAAW,EAAE,kBAAkB,EAAE,GAAG,CAAC;MACrE,MAAMlD,UAAU,GAAGiD,YAAY,CAACC,WAAW,EAAE,kBAAkB,CAAC;MAChE,MAAMtD,KAAK,GAAGqD,YAAY,CAACC,WAAW,EAAE,aAAa,EAAE,GAAG,CAAC;MAC3D,MAAMiC,SAAS,GAAGlC,YAAY,CAACC,WAAW,EAAE,iBAAiB,EAAE,UAAU,CAAC;MAC1E,MAAMkC,SAAS,GAAGnC,YAAY,CAACC,WAAW,EAAE,iBAAiB,EAAE,UAAU,CAAC;MAC1E,IAAIhD,cAAc,GAAG,CAACkD,EAAE,GAAGF,WAAW,CAACK,UAAU,CAACC,YAAY,CAAC,sBAAsB,CAAC,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,SAAS;MACzI,IAAI,CAACvD,cAAc,EACfA,cAAc,GAAG,GAAG;MACxB,MAAMC,cAAc,GAAG,CAACmE,EAAE,GAAGpB,WAAW,CAACK,UAAU,CAACC,YAAY,CAAC,sBAAsB,CAAC,MAAM,IAAI,IAAIc,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACb,SAAS;MAC3I,IAAI,CAACtD,cAAc,EACf,MAAM,IAAI4C,KAAK,CAAC,6BAA6B,CAAC;MAClD,OAAO;QACHhD,UAAU,EAAE+D,KAAK,CAACuB,OAAO,CAACtF,UAAU,CAAC,GAAGA,UAAU,CAACiE,GAAG,CAACC,CAAC,IAAIqB,UAAU,CAACrB,CAAC,CAAC,CAAC,GAAG,CAACqB,UAAU,CAACvF,UAAU,CAAC,EAAEuF,UAAU,CAACvF,UAAU,CAAC,EAAEuF,UAAU,CAACvF,UAAU,CAAC,CAAC;QACrJC,UAAU,EAAE8D,KAAK,CAACuB,OAAO,CAACrF,UAAU,CAAC,GAAGA,UAAU,CAACgE,GAAG,CAACC,CAAC,IAAIqB,UAAU,CAACrB,CAAC,CAAC,CAAC,GAAG,CAACqB,UAAU,CAACtF,UAAU,CAAC,EAAEsF,UAAU,CAACtF,UAAU,CAAC,EAAEsF,UAAU,CAACtF,UAAU,CAAC,CAAC;QACrJJ,KAAK,EAAEkE,KAAK,CAACuB,OAAO,CAACzF,KAAK,CAAC,GAAGA,KAAK,CAACoE,GAAG,CAACC,CAAC,IAAIqB,UAAU,CAACrB,CAAC,CAAC,CAAC,GAAG,CAACqB,UAAU,CAAC1F,KAAK,CAAC,EAAE0F,UAAU,CAAC1F,KAAK,CAAC,EAAE0F,UAAU,CAAC1F,KAAK,CAAC,CAAC;QACvHE,SAAS,EAAEgE,KAAK,CAACuB,OAAO,CAACF,SAAS,CAAC,GAAGA,SAAS,CAACnB,GAAG,CAACC,CAAC,IAAIqB,UAAU,CAACrB,CAAC,CAAC,CAAC,GAAG,CAACqB,UAAU,CAACH,SAAS,CAAC,EAAEG,UAAU,CAACH,SAAS,CAAC,EAAEG,UAAU,CAACH,SAAS,CAAC,CAAC;QAC/ItF,SAAS,EAAEiE,KAAK,CAACuB,OAAO,CAACD,SAAS,CAAC,GAAGA,SAAS,CAACpB,GAAG,CAACC,CAAC,IAAIqB,UAAU,CAACrB,CAAC,CAAC,CAAC,GAAG,CAACqB,UAAU,CAACF,SAAS,CAAC,EAAEE,UAAU,CAACF,SAAS,CAAC,EAAEE,UAAU,CAACF,SAAS,CAAC,CAAC;QAC/IlF,cAAc,EAAEoF,UAAU,CAACpF,cAAc,CAAC;QAC1CC,cAAc,EAAEmF,UAAU,CAACnF,cAAc;MAC7C,CAAC;IACL,CAAC,CACD,OAAOyC,CAAC,EAAE,CACV;IACA8B,KAAK,GAAGH,GAAG,CAACI,OAAO,CAAC,YAAY,EAAEG,GAAG,CAAC;EAC1C;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMS,YAAY,CAAC;EACf7F,WAAWA,CAAC8F,OAAO,EAAE;IACjB,IAAI,CAACA,OAAO,GAAG;MACXC,KAAK,EAAED,OAAO,IAAIA,OAAO,CAACC,KAAK,KAAKC,SAAS,GAAGF,OAAO,CAACC,KAAK,GAAG,KAAK;MACrEE,UAAU,EAAEH,OAAO,IAAIA,OAAO,CAACG,UAAU,KAAKD,SAAS,GAAGF,OAAO,CAACG,UAAU,GAAG,IAAI;MACnFC,aAAa,EAAEJ,OAAO,IAAIA,OAAO,CAACI,aAAa,KAAKF,SAAS,GAAGF,OAAO,CAACI,aAAa,GAAG;IAC5F,CAAC;EACL;EACAC,OAAOA,CAACC,gBAAgB,EAAE;IACtB,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpC,MAAMR,KAAK,GAAG,IAAI,CAACD,OAAO,CAACC,KAAK;MAChC,MAAMS,QAAQ,GAAG,IAAIC,QAAQ,CAACL,gBAAgB,CAACM,MAAM,CAAC;MACtD;MACA;MACA,IAAIF,QAAQ,CAACG,SAAS,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;QAClCJ,MAAM,CAAC,IAAIlD,KAAK,CAAC,kBAAkB,CAAC,CAAC;QACrC;MACJ;MACA,MAAMc,MAAM,GAAGqC,QAAQ,CAACI,UAAU;MAClC,IAAIC,MAAM,GAAG,CAAC;MACd,IAAIC,KAAK,GAAG,CAAC;MACb,IAAIC,MAAM,CAAC,CAAC;MACZ,OAAOF,MAAM,GAAG1C,MAAM,EAAE;QACpB,IAAI,EAAE2C,KAAK,GAAG,GAAG,EAAE;UACfP,MAAM,CAAC,IAAIlD,KAAK,0BAAAoB,MAAA,CAA0BqC,KAAK,wBAAW,CAAC,CAAC;UAC5D;QACJ;QACA,IAAIN,QAAQ,CAACQ,QAAQ,CAACH,MAAM,CAAC,KAAK,IAAI,EAAE;UACpCN,MAAM,CAAC,IAAIlD,KAAK,mCAAAoB,MAAA,CAAmCoC,MAAM,CAAC9B,QAAQ,CAAC,EAAE,CAAC,iBAAAN,MAAA,CAAc+B,QAAQ,CAACQ,QAAQ,CAACH,MAAM,CAAC,CAAC9B,QAAQ,CAAC,EAAE,CAAC,CAAE,CAAC,CAAC;UAC9H;QACJ;QACAgC,MAAM,GAAGP,QAAQ,CAACQ,QAAQ,CAACH,MAAM,GAAG,CAAC,CAAC;QACtC,IAAId,KAAK,EACLvD,OAAO,CAACyE,GAAG,YAAAxC,MAAA,CAAYsC,MAAM,CAAChC,QAAQ,CAAC,EAAE,CAAC,CAAE,CAAC;QACjD,IAAIgC,MAAM,KAAK,IAAI,EAAE;UACjB,IAAIhB,KAAK,EACLvD,OAAO,CAACyE,GAAG,CAAC,4BAA4B,CAAC;UAC7C;UACA;UACA;UACA,MAAMC,QAAQ,GAAGL,MAAM,GAAG,CAAC;UAC3B;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACoB,IAAIL,QAAQ,CAACW,SAAS,CAACD,QAAQ,CAAC,KAAK,UAAU,EAAE;YAC7C;YACA,MAAME,UAAU,GAAGF,QAAQ,GAAG,CAAC;YAC/B,IAAIG,MAAM,CAAC,CAAC;YACZ;YACA;YACA,IAAIb,QAAQ,CAACG,SAAS,CAACS,UAAU,CAAC,KAAK,MAAM,EAAE;cAC3CC,MAAM,GAAG,KAAK;YAClB,CAAC,MACI,IAAIb,QAAQ,CAACG,SAAS,CAACS,UAAU,CAAC,KAAK,MAAM,EAAE;cAChDC,MAAM,GAAG,IAAI;YACjB,CAAC,MACI;cACDd,MAAM,CAAC,IAAIlD,KAAK,CAAC,iDAAiD,CAAC,CAAC;cACpE;YACJ;YACA,IAAImD,QAAQ,CAACG,SAAS,CAACS,UAAU,GAAG,CAAC,EAAE,CAACC,MAAM,CAAC,KAAK,MAAM,EAAE;cACxDd,MAAM,CAAC,IAAIlD,KAAK,CAAC,yCAAyC,CAAC,CAAC;cAC5D;YACJ;YACA;YACA;YACA,MAAMiE,cAAc,GAAGd,QAAQ,CAACW,SAAS,CAACC,UAAU,GAAG,CAAC,EAAE,CAACC,MAAM,CAAC;YAClE,IAAIC,cAAc,GAAG,UAAU,EAAE;cAC7Bf,MAAM,CAAC,IAAIlD,KAAK,CAAC,iDAAiD,CAAC,CAAC;cACpE;YACJ;YACA;YACA;YACA;YACA;YACA;YACA,MAAMkE,QAAQ,GAAGH,UAAU,GAAGE,cAAc,CAAC,CAAC;YAC9C,MAAME,KAAK,GAAGhB,QAAQ,CAACG,SAAS,CAACY,QAAQ,EAAE,CAACF,MAAM,CAAC,CAAC,CAAC;YACrD;YACA,MAAMI,YAAY,GAAGF,QAAQ,GAAG,CAAC;YACjC,IAAIG,cAAc,GAAG,CAAC;YACtB,KAAK,IAAIC,CAAC,GAAGF,YAAY,EAAEE,CAAC,GAAGF,YAAY,GAAG,EAAE,GAAGD,KAAK,EAAEG,CAAC,IAAI,EAAE,EAAE;cAC/D;cACA;cACA,IAAInB,QAAQ,CAACG,SAAS,CAACgB,CAAC,EAAE,CAACN,MAAM,CAAC,KAAK,MAAM,EAAE;gBAC3C;gBACAK,cAAc,GAAGlB,QAAQ,CAACW,SAAS,CAACQ,CAAC,GAAG,CAAC,EAAE,CAACN,MAAM,CAAC;cACvD;YACJ;YACA,MAAMO,gBAAgB,GAAG,CAAC,CAAC,CAAC;YAC5B,MAAMC,gBAAgB,GAAGN,QAAQ,GAAG,CAAC,GAAGC,KAAK,GAAG,EAAE,GAAGI,gBAAgB;YACrE,MAAME,MAAM,GAAG,EAAE;YACjB,KAAK,IAAIH,CAAC,GAAGE,gBAAgB,EAAEF,CAAC,GAAGE,gBAAgB,GAAGH,cAAc,GAAG,EAAE,EAAEC,CAAC,IAAI,EAAE,EAAE;cAChF,MAAM9E,KAAK,GAAG;gBACVkF,MAAM,EAAEvB,QAAQ,CAACW,SAAS,CAACQ,CAAC,EAAE,CAACN,MAAM,CAAC;gBACtCW,IAAI,EAAExB,QAAQ,CAACW,SAAS,CAACQ,CAAC,GAAG,CAAC,EAAE,CAACN,MAAM,CAAC;gBACxC;gBACA;gBACA;gBACAY,UAAU,EAAEzB,QAAQ,CAACW,SAAS,CAACQ,CAAC,GAAG,CAAC,EAAE,CAACN,MAAM,CAAC;gBAC9Ca,eAAe,EAAE1B,QAAQ,CAACW,SAAS,CAACQ,CAAC,GAAG,EAAE,EAAE,CAACN,MAAM,CAAC;gBACpDrC,KAAK,EAAE,CAAC,CAAC;gBACTI,GAAG,EAAE,CAAC,CAAC;gBACP+C,KAAK,EAAE;cACX,CAAC;cACD,IAAI,CAACtF,KAAK,CAACoF,UAAU,EAAE;gBACnB;gBACApF,KAAK,CAACmC,KAAK,GAAG,CAAC;gBACfnC,KAAK,CAACsF,KAAK,GAAG,IAAI;cACtB,CAAC,MACI;gBACDtF,KAAK,CAACmC,KAAK,GAAGoC,UAAU,GAAGvE,KAAK,CAACoF,UAAU;gBAC3CpF,KAAK,CAACsF,KAAK,GAAG,KAAK;cACvB;cACAtF,KAAK,CAACuC,GAAG,GAAGvC,KAAK,CAACmC,KAAK,GAAGnC,KAAK,CAACmF,IAAI;cACpCF,MAAM,CAACM,IAAI,CAACvF,KAAK,CAAC;YACtB;YACA,IAAI,IAAI,CAACiD,OAAO,CAACI,aAAa,IAAI4B,MAAM,CAAC3D,MAAM,EAAE;cAC7C,MAAMkE,UAAU,GAAG,IAAIC,IAAI,CAAC,CAAC9B,QAAQ,CAAC,CAAC;cACvC,MAAM+B,IAAI,GAAG,EAAE;cACf,KAAK,MAAM1F,KAAK,IAAIiF,MAAM,EAAE;gBACxB,IAAIjF,KAAK,CAACsF,KAAK,IAAI,CAAC,IAAI,CAACrC,OAAO,CAACG,UAAU,EAAE;kBACzC,SAAS,CAAC;gBACd;gBACA,MAAMuC,SAAS,GAAGH,UAAU,CAAChD,KAAK,CAACxC,KAAK,CAACmC,KAAK,EAAEnC,KAAK,CAACuC,GAAG,GAAG,CAAC,EAAE,YAAY,CAAC;gBAC5E;gBACA;gBACA;gBACA;gBACAmD,IAAI,CAACH,IAAI,CAACI,SAAS,CAAC;cACxB;cACAlC,OAAO,CAACiC,IAAI,CAAC;YACjB;UACJ;QACJ;QACA1B,MAAM,IAAI,CAAC,GAAGL,QAAQ,CAACG,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;MAChD;IACJ,CAAC,CAAC;EACN;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM4B,sBAAsB,GAAG,MAAOC,QAAQ,IAAK;EAC/C,MAAMC,QAAQ,GAAGjE,UAAU,CAACgE,QAAQ,CAAC;EACrC,IAAI,CAACC,QAAQ,EACT,MAAM,IAAIrF,wBAAwB,CAAC,iCAAiC,CAAC;EACzE,MAAMsF,YAAY,GAAG,IAAI/C,YAAY,CAAC;IAAEI,UAAU,EAAE,IAAI;IAAEC,aAAa,EAAE;EAAK,CAAC,CAAC;EAChF,MAAM4B,MAAM,GAAG,MAAMc,YAAY,CAACzC,OAAO,CAACuC,QAAQ,CAAC;EACnD,IAAIZ,MAAM,CAAC3D,MAAM,KAAK,CAAC,EACnB,MAAM,IAAIf,oBAAoB,CAAC,mCAAmC,CAAC;EACvE,OAAO;IACH1C,GAAG,EAAE,IAAImI,UAAU,CAAC,MAAMf,MAAM,CAAC,CAAC,CAAC,CAACgB,WAAW,CAAC,CAAC,CAAC;IAClDnI,OAAO,EAAE,IAAIkI,UAAU,CAAC,MAAMf,MAAM,CAAC,CAAC,CAAC,CAACgB,WAAW,CAAC,CAAC,CAAC;IACtDH;EACJ,CAAC;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,oBAAoB,GAAIC,IAAI,IAAK;EACnC,OAAO,IAAI3C,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACpC,MAAM0C,GAAG,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IACzCF,GAAG,CAACG,MAAM,GAAG,MAAM;MAAE9C,OAAO,CAAC2C,GAAG,CAAC;IAAE,CAAC;IACpCA,GAAG,CAACI,OAAO,GAAInG,CAAC,IAAK;MAAEqD,MAAM,CAACrD,CAAC,CAAC;IAAE,CAAC;IACnC+F,GAAG,CAACK,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACR,IAAI,CAAC;EACvC,CAAC,CAAC;AACN,CAAC;AAED,MAAMS,UAAU,SAAStK,MAAM,CAAC;EAC5B;AACJ;AACA;AACA;AACA;EACIa,WAAWA,CAACsC,QAAQ,EAAEoH,OAAO,EAAE;IAC3B,KAAK,CAACA,OAAO,CAAC;IACd,IAAIpH,QAAQ,EACR,IAAI,CAACqH,SAAS,GAAGrH,QAAQ;IAC7B,IAAI,CAACsH,uBAAuB,GAAG,IAAIxK,cAAc,CAAC,CAAC;EACvD;EACA;AACJ;AACA;AACA;AACA;AACA;EACIyK,WAAWA,CAACvH,QAAQ,EAAE;IAClB,IAAI,CAACqH,SAAS,GAAGrH,QAAQ;IACzB,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACIwH,sBAAsBA,CAAChE,OAAO,EAAE;IAC5B,IAAI,CAACiE,oBAAoB,GAAGjE,OAAO;IACnC,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACIkE,mBAAmBA,CAAA,EAAG;IAClB,IAAI,CAAC,IAAI,CAACL,SAAS,EACfnH,OAAO,CAACC,IAAI,CAAC,qOAAqO,CAAC;IACvP;IACA,MAAMC,QAAQ,GAAG,IAAI3C,sBAAsB,CAAC;MACxCO,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACrBD,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACrBH,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAChBC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACpBC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACpBK,cAAc,EAAE,CAAC;MACjBD,cAAc,EAAE,CAAC;MACjBD,eAAe,EAAE,CAAC;MAClBI,OAAO,EAAE,IAAItB,OAAO,CAAC,CAAC;MACtBqB,GAAG,EAAE,IAAIrB,OAAO,CAAC;IACrB,CAAC,CAAC;IACF,OAAO,IAAIT,YAAY,CAAC;MACpBgE,KAAK,EAAE,EAAE;MACTE,MAAM,EAAE,EAAE;MACVC,IAAI,EAAE7D,aAAa;MACnBqD,UAAU,EAAEtD,oBAAoB;MAChCyD,QAAQ;MACRJ,QAAQ,EAAE,IAAI,CAACqH,SAAS;MACxB3G,mBAAmB,EAAE,IAAI,CAAC+G;IAC9B,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAM9G,MAAMA,CAACN,YAAY,EAAEgG,QAAQ,EAAEsB,SAAS,EAAEC,aAAa,EAAE;IAC3D;IACA,MAAMC,WAAW,GAAGD,aAAa,GAAG,IAAI5B,IAAI,CAAC,CAAC4B,aAAa,CAAC,EAAE;MAAEnH,IAAI,EAAE;IAAa,CAAC,CAAC,GAAGiD,SAAS;IACjG,MAAMoE,OAAO,GAAG,IAAI9B,IAAI,CAAC,CAAC2B,SAAS,CAAC,EAAE;MAAElH,IAAI,EAAE;IAAa,CAAC,CAAC;IAC7D,IAAIsH,QAAQ;IACZ,IAAIC,YAAY;IAChB,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAI,OAAOC,iBAAiB,KAAK,WAAW,EAAE;MAC1C,MAAMC,GAAG,GAAG,MAAMpE,OAAO,CAACqE,GAAG,CAAC,CAC1BP,WAAW,GAAGpB,oBAAoB,CAACoB,WAAW,CAAC,GAAG9D,OAAO,CAACC,OAAO,CAACN,SAAS,CAAC,EAC5E+C,oBAAoB,CAACqB,OAAO,CAAC,CAChC,CAAC;MACFE,YAAY,GAAGG,GAAG,CAAC,CAAC,CAAC;MACrBJ,QAAQ,GAAGI,GAAG,CAAC,CAAC,CAAC;MACjBF,SAAS,GAAG,IAAI;IACpB,CAAC,MACI;MACD,MAAME,GAAG,GAAG,MAAMpE,OAAO,CAACqE,GAAG,CAAC,CAC1BP,WAAW,GAAGK,iBAAiB,CAACL,WAAW,EAAE;QAAEQ,gBAAgB,EAAE;MAAQ,CAAC,CAAC,GAAGtE,OAAO,CAACC,OAAO,CAACN,SAAS,CAAC,EACxGwE,iBAAiB,CAACJ,OAAO,EAAE;QAAEO,gBAAgB,EAAE;MAAQ,CAAC,CAAC,CAC5D,CAAC;MACFL,YAAY,GAAGG,GAAG,CAAC,CAAC,CAAC;MACrBJ,QAAQ,GAAGI,GAAG,CAAC,CAAC,CAAC;IACrB;IACA,MAAM9J,OAAO,GAAG,IAAItB,OAAO,CAACiL,YAAY,IAAI,IAAIM,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEtL,SAAS,EAAEC,mBAAmB,EAAEA,mBAAmB,EAAEC,YAAY,EAAEC,wBAAwB,EAAEC,UAAU,EAAEC,gBAAgB,EAAE,CAAC,EAAEV,oBAAoB,CAAC;IACpN0B,OAAO,CAACkK,KAAK,GAAGN,SAAS;IACzB5J,OAAO,CAACc,WAAW,GAAG,IAAI;IAC1B,MAAMf,GAAG,GAAG,IAAIrB,OAAO,CAACgL,QAAQ,EAAE/K,SAAS,EAAEC,mBAAmB,EAAEA,mBAAmB,EAAEC,YAAY,EAAEC,wBAAwB,EAAEC,UAAU,EAAEC,gBAAgB,EAAE,CAAC,EAAEX,cAAc,CAAC;IAC/K0B,GAAG,CAACmK,KAAK,GAAGN,SAAS;IACrB7J,GAAG,CAACe,WAAW,GAAG,IAAI;IACtBkB,YAAY,CAACC,KAAK,GAAGyH,QAAQ,CAACzH,KAAK;IACnCD,YAAY,CAACG,MAAM,GAAGuH,QAAQ,CAACvH,MAAM;IACrCH,YAAY,CAACD,QAAQ,CAAC/B,OAAO,GAAGA,OAAO;IACvCgC,YAAY,CAACD,QAAQ,CAAChC,GAAG,GAAGA,GAAG;IAC/BiC,YAAY,CAACD,QAAQ,CAACrC,UAAU,GAAGsI,QAAQ,CAACtI,UAAU;IACtDsC,YAAY,CAACD,QAAQ,CAACpC,UAAU,GAAGqI,QAAQ,CAACrI,UAAU;IACtDqC,YAAY,CAACD,QAAQ,CAACvC,SAAS,GAAGwI,QAAQ,CAACxI,SAAS;IACpDwC,YAAY,CAACD,QAAQ,CAACtC,SAAS,GAAGuI,QAAQ,CAACvI,SAAS;IACpDuC,YAAY,CAACD,QAAQ,CAACxC,KAAK,GAAGyI,QAAQ,CAACzI,KAAK;IAC5CyC,YAAY,CAACD,QAAQ,CAAClC,cAAc,GAAGmI,QAAQ,CAACnI,cAAc;IAC9DmC,YAAY,CAACD,QAAQ,CAACjC,cAAc,GAAGkI,QAAQ,CAAClI,cAAc;IAC9DkC,YAAY,CAACD,QAAQ,CAACnC,eAAe,GAAGU,IAAI,CAAC6J,GAAG,CAAC,CAAC,EAAEnC,QAAQ,CAAClI,cAAc,CAAC;IAC5EkC,YAAY,CAACD,QAAQ,CAACjB,WAAW,GAAG,IAAI;IACxCkB,YAAY,CAACM,MAAM,CAAC,CAAC;EACzB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM8H,aAAa,SAAStB,UAAU,CAAC;EACnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIuB,IAAIA,CAAAC,KAAA,EAAoCC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;IAAA,IAAhE,CAACC,MAAM,EAAEC,UAAU,EAAEC,WAAW,CAAC,GAAAN,KAAA;IAClC,MAAMtI,YAAY,GAAG,IAAI,CAACqH,mBAAmB,CAAC,CAAC;IAC/C,IAAItJ,GAAG;IACP,IAAIC,OAAO;IACX,IAAIgI,QAAQ;IACZ,MAAM6C,SAAS,GAAG,MAAAA,CAAA,KAAY;MAC1B,IAAI9K,GAAG,IAAIC,OAAO,IAAIgI,QAAQ,EAAE;QAC5B;QACA,IAAI;UACA,MAAM,IAAI,CAAC1F,MAAM,CAACN,YAAY,EAAEgG,QAAQ,EAAEjI,GAAG,EAAEC,OAAO,CAAC;QAC3D,CAAC,CACD,OAAO8K,KAAK,EAAE;UACV,IAAI,CAAC/B,OAAO,CAACgC,SAAS,CAACL,MAAM,CAAC;UAC9B,IAAI,CAAC3B,OAAO,CAACgC,SAAS,CAACJ,UAAU,CAAC;UAClC,IAAI,CAAC5B,OAAO,CAACgC,SAAS,CAACH,WAAW,CAAC;UACnC,IAAI,OAAOH,OAAO,KAAK,UAAU,EAC7BA,OAAO,CAACK,KAAK,CAAC;UAClB9I,YAAY,CAACQ,uBAAuB,CAAC,CAAC;UACtC;QACJ;QACA,IAAI,OAAO+H,MAAM,KAAK,UAAU,EAC5BA,MAAM,CAACvI,YAAY,CAAC;QACxB,IAAI,CAAC+G,OAAO,CAACiC,OAAO,CAACN,MAAM,CAAC;QAC5B,IAAI,CAAC3B,OAAO,CAACiC,OAAO,CAACL,UAAU,CAAC;QAChC,IAAI,CAAC5B,OAAO,CAACiC,OAAO,CAACJ,WAAW,CAAC;QACjC5I,YAAY,CAACQ,uBAAuB,CAAC,CAAC;MAC1C;IACJ,CAAC;IACD,IAAIyI,mBAAmB,GAAG,IAAI;IAC9B,IAAIC,QAAQ,GAAG,CAAC;IAChB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIC,uBAAuB,GAAG,IAAI;IAClC,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAIC,aAAa,GAAG,CAAC;IACrB,IAAIC,wBAAwB,GAAG,IAAI;IACnC,IAAIC,aAAa,GAAG,CAAC;IACrB,IAAIC,cAAc,GAAG,CAAC;IACtB,MAAMC,eAAe,GAAGA,CAAA,KAAM;MAC1B,IAAI,OAAOlB,UAAU,KAAK,UAAU,EAAE;QAClC,MAAMmB,KAAK,GAAGT,QAAQ,GAAGG,YAAY,GAAGG,aAAa;QACrD,MAAMI,MAAM,GAAGT,SAAS,GAAGG,aAAa,GAAGG,cAAc;QACzD,MAAMI,gBAAgB,GAAGZ,mBAAmB,IAAIG,uBAAuB,IAAIG,wBAAwB;QACnGf,UAAU,CAAC,IAAIsB,aAAa,CAAC,UAAU,EAAE;UAAED,gBAAgB;UAAED,MAAM;UAAED;QAAM,CAAC,CAAC,CAAC;MAClF;IACJ,CAAC;IACD,IAAI,CAAC5C,OAAO,CAACgD,SAAS,CAACrB,MAAM,CAAC;IAC9B,IAAI,CAAC3B,OAAO,CAACgD,SAAS,CAACpB,UAAU,CAAC;IAClC,IAAI,CAAC5B,OAAO,CAACgD,SAAS,CAACnB,WAAW,CAAC;IACnC,MAAMoB,SAAS,GAAG,IAAI/M,UAAU,CAAC,IAAI,CAACgK,uBAAuB,CAAC;IAC9D+C,SAAS,CAACC,eAAe,CAAC,aAAa,CAAC;IACxCD,SAAS,CAACE,gBAAgB,CAAC,IAAI,CAACC,aAAa,CAAC;IAC9CH,SAAS,CAACI,OAAO,CAAC,IAAI,CAACC,IAAI,CAAC;IAC5BL,SAAS,CAACM,kBAAkB,CAAC,IAAI,CAACC,eAAe,CAAC;IAClDP,SAAS,CAAC3B,IAAI,CAACK,MAAM,EAAE,MAAO3E,MAAM,IAAK;MACrC;AACZ;AACA;MACY,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAC1B,MAAM,IAAIrD,KAAK,CAAC,oBAAoB,CAAC;MACzC3C,GAAG,GAAGgG,MAAM;MACZ,MAAM8E,SAAS,CAAC,CAAC;IACrB,CAAC,EAAGtI,CAAC,IAAK;MACN0I,mBAAmB,GAAG1I,CAAC,CAACsJ,gBAAgB;MACxCV,SAAS,GAAG5I,CAAC,CAACqJ,MAAM;MACpBV,QAAQ,GAAG3I,CAAC,CAACoJ,KAAK;MAClBD,eAAe,CAAC,CAAC;IACrB,CAAC,EAAGZ,KAAK,IAAK;MACV,IAAI,CAAC/B,OAAO,CAACgC,SAAS,CAACL,MAAM,CAAC;MAC9B,IAAI,OAAOD,OAAO,KAAK,UAAU,EAC7BA,OAAO,CAACK,KAAK,CAAC;IACtB,CAAC,CAAC;IACF,MAAM0B,aAAa,GAAG,IAAIvN,UAAU,CAAC,IAAI,CAACgK,uBAAuB,CAAC;IAClEuD,aAAa,CAACP,eAAe,CAAC,aAAa,CAAC;IAC5CO,aAAa,CAACN,gBAAgB,CAAC,IAAI,CAACC,aAAa,CAAC;IAClDK,aAAa,CAACJ,OAAO,CAAC,IAAI,CAACC,IAAI,CAAC;IAChCG,aAAa,CAACF,kBAAkB,CAAC,IAAI,CAACC,eAAe,CAAC;IACtDC,aAAa,CAACnC,IAAI,CAACM,UAAU,EAAE,MAAO5E,MAAM,IAAK;MAC7C;AACZ;AACA;MACY,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAC1B,MAAM,IAAIrD,KAAK,CAAC,wBAAwB,CAAC;MAC7C1C,OAAO,GAAG+F,MAAM;MAChB,MAAM8E,SAAS,CAAC,CAAC;IACrB,CAAC,EAAGtI,CAAC,IAAK;MACN6I,uBAAuB,GAAG7I,CAAC,CAACsJ,gBAAgB;MAC5CP,aAAa,GAAG/I,CAAC,CAACqJ,MAAM;MACxBP,YAAY,GAAG9I,CAAC,CAACoJ,KAAK;MACtBD,eAAe,CAAC,CAAC;IACrB,CAAC,EAAGZ,KAAK,IAAK;MACV,IAAI,CAAC/B,OAAO,CAACgC,SAAS,CAACJ,UAAU,CAAC;MAClC,IAAI,OAAOF,OAAO,KAAK,UAAU,EAC7BA,OAAO,CAACK,KAAK,CAAC;IACtB,CAAC,CAAC;IACF,MAAM2B,cAAc,GAAG,IAAIxN,UAAU,CAAC,IAAI,CAACgK,uBAAuB,CAAC;IACnE;IACAwD,cAAc,CAACP,gBAAgB,CAAC,IAAI,CAACC,aAAa,CAAC;IACnDM,cAAc,CAACL,OAAO,CAAC,IAAI,CAACC,IAAI,CAAC;IACjCI,cAAc,CAACH,kBAAkB,CAAC,IAAI,CAACC,eAAe,CAAC;IACvDE,cAAc,CAACpC,IAAI,CAACO,WAAW,EAAE,MAAO8B,IAAI,IAAK;MAC7C;AACZ;AACA;MACY,IAAI,OAAOA,IAAI,KAAK,QAAQ,EACxB,MAAM,IAAIhK,KAAK,CAAC,yBAAyB,CAAC;MAC9C;MACA;MACAsF,QAAQ,GAAG2E,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;MAC3B,MAAM7B,SAAS,CAAC,CAAC;IACrB,CAAC,EAAGtI,CAAC,IAAK;MACNgJ,wBAAwB,GAAGhJ,CAAC,CAACsJ,gBAAgB;MAC7CJ,cAAc,GAAGlJ,CAAC,CAACqJ,MAAM;MACzBJ,aAAa,GAAGjJ,CAAC,CAACoJ,KAAK;MACvBD,eAAe,CAAC,CAAC;IACrB,CAAC,EAAGZ,KAAK,IAAK;MACV,IAAI,CAAC/B,OAAO,CAACgC,SAAS,CAACH,WAAW,CAAC;MACnC,IAAI,OAAOH,OAAO,KAAK,UAAU,EAC7BA,OAAO,CAACK,KAAK,CAAC;IACtB,CAAC,CAAC;IACF,OAAO9I,YAAY;EACvB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM6K,YAAY,SAAS/D,UAAU,CAAC;EAClC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIuB,IAAIA,CAACyC,GAAG,EAAEvC,MAAM,EAAEC,UAAU,EAAEC,OAAO,EAAE;IACnC,MAAMzI,YAAY,GAAG,IAAI,CAACqH,mBAAmB,CAAC,CAAC;IAC/C,MAAM0D,MAAM,GAAG,IAAI9N,UAAU,CAAC,IAAI,CAACgK,uBAAuB,CAAC;IAC3D8D,MAAM,CAACd,eAAe,CAAC,aAAa,CAAC;IACrCc,MAAM,CAACb,gBAAgB,CAAC,IAAI,CAACC,aAAa,CAAC;IAC3CY,MAAM,CAACX,OAAO,CAAC,IAAI,CAACC,IAAI,CAAC;IACzBU,MAAM,CAACT,kBAAkB,CAAC,IAAI,CAACC,eAAe,CAAC;IAC/C,IAAI,CAACxD,OAAO,CAACgD,SAAS,CAACe,GAAG,CAAC;IAC3BC,MAAM,CAAC1C,IAAI,CAACyC,GAAG,EAAE,MAAOE,IAAI,IAAK;MAC7B;AACZ;AACA;MACY,IAAI,OAAOA,IAAI,KAAK,QAAQ,EACxB,MAAM,IAAItK,KAAK,CAAC,gEAAgE,CAAC;MACrF,MAAMuK,UAAU,GAAG,IAAI/E,UAAU,CAAC8E,IAAI,CAAC;MACvC,IAAIE,OAAO;MACX,IAAIC,WAAW;MACf,IAAInF,QAAQ;MACZ,IAAI;QACA,MAAMoF,gBAAgB,GAAG,MAAMtF,sBAAsB,CAACmF,UAAU,CAAC;QACjE;QACAC,OAAO,GAAGE,gBAAgB,CAACrN,GAAG;QAC9BoN,WAAW,GAAGC,gBAAgB,CAACpN,OAAO;QACtCgI,QAAQ,GAAGoF,gBAAgB,CAACpF,QAAQ;MACxC,CAAC,CACD,OAAOzF,CAAC,EAAE;QACN;QACA,IAAIA,CAAC,YAAYI,wBAAwB,IAAIJ,CAAC,YAAYE,oBAAoB,EAAE;UAC5EZ,OAAO,CAACC,IAAI,6CAAAgC,MAAA,CAA6CgJ,GAAG,qFAAkF,CAAC;UAC/I9E,QAAQ,GAAG;YACPtI,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YACrBC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YACrBJ,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAChBM,cAAc,EAAE,CAAC;YACjBC,cAAc,EAAE,CAAC;YACjBN,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YACpBC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;UACvB,CAAC;UACDyN,OAAO,GAAGD,UAAU;QACxB,CAAC,MACI;UACD,MAAM1K,CAAC;QACX;MACJ;MACA;MACA,IAAI;QACA,MAAM,IAAI,CAACD,MAAM,CAACN,YAAY,EAAEgG,QAAQ,EAAEkF,OAAO,EAAEC,WAAW,CAAC;MACnE,CAAC,CACD,OAAOrC,KAAK,EAAE;QACV,IAAI,CAAC/B,OAAO,CAACgC,SAAS,CAAC+B,GAAG,CAAC;QAC3B,IAAI,OAAOrC,OAAO,KAAK,UAAU,EAC7BA,OAAO,CAACK,KAAK,CAAC;QAClB9I,YAAY,CAACQ,uBAAuB,CAAC,CAAC;QACtC;MACJ;MACA,IAAI,OAAO+H,MAAM,KAAK,UAAU,EAC5BA,MAAM,CAACvI,YAAY,CAAC;MACxB,IAAI,CAAC+G,OAAO,CAACiC,OAAO,CAAC8B,GAAG,CAAC;MACzB9K,YAAY,CAACQ,uBAAuB,CAAC,CAAC;IAC1C,CAAC,EAAEgI,UAAU,EAAGM,KAAK,IAAK;MACtB,IAAI,CAAC/B,OAAO,CAACgC,SAAS,CAAC+B,GAAG,CAAC;MAC3B,IAAI,OAAOrC,OAAO,KAAK,UAAU,EAC7BA,OAAO,CAACK,KAAK,CAAC;IACtB,CAAC,CAAC;IACF,OAAO9I,YAAY;EACvB;AACJ;AAEA,SAAS5C,sBAAsB,EAAEgL,aAAa,EAAEyC,YAAY,EAAEA,YAAY,IAAIQ,WAAW,EAAEnI,YAAY,EAAEjH,YAAY,EAAEwD,MAAM,EAAEqG,sBAAsB,EAAE/D,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}